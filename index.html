<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEMR 2.9\" ESL Uploader</title>
    <style>
        :root {
            --primary-color: #007AFF;
            --secondary-color: #5AC8FA;
            --success-color: #34C759;
            --error-color: #FF3B30;
            --warning-color: #FF9500;
            --bg-color: #F2F2F7;
            --card-bg: rgba(255, 255, 255, 0.9);
            --glass-bg: rgba(255, 255, 255, 0.85);
            --text-color: #1D1D1F;
            --text-secondary: #6D6D73;
            --border-color: rgba(0, 0, 0, 0.1);
            --shadow-light: rgba(0, 0, 0, 0.04);
            --shadow-medium: rgba(0, 0, 0, 0.08);
            --shadow-heavy: rgba(0, 0, 0, 0.12);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #F2F2F7 0%, #E5E5EA 100%);
            color: var(--text-color);
            min-height: 100vh;
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 24px;
        }

        .card {
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 20px;
            border: 1px solid var(--border-color);
            box-shadow:
                0 8px 32px var(--shadow-light),
                0 1px 2px var(--shadow-medium),
                inset 0 1px 0 rgba(255, 255, 255, 0.5);
            padding: 28px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .card:hover {
            transform: translateY(-2px);
            box-shadow:
                0 12px 40px var(--shadow-medium),
                0 4px 8px var(--shadow-light),
                inset 0 1px 0 rgba(255, 255, 255, 0.6);
        }

        .header {
            text-align: center;
            margin-bottom: 32px;
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 8px;
            letter-spacing: -0.02em;
        }

        .subtitle {
            font-size: 1.1rem;
            color: var(--text-secondary);
            font-weight: 400;
        }

        .layout {
            display: grid;
            grid-template-columns: 320px 1fr;
            gap: 24px;
        }

        .form-group {
            margin-top: 18px;
        }

        label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
        }

        select, input[type="number"], input[type="text"] {
            width: 100%;
            padding: 10px 12px;
            border-radius: 10px;
            border: 1px solid var(--border-color);
            background: var(--card-bg);
            color: var(--text-color);
            font-size: 15px;
        }

        button {
            width: 100%;
            padding: 16px 24px;
            border-radius: 16px;
            border: none;
            font-weight: 600;
            font-size: 16px;
            cursor: pointer;
            background: var(--primary-color);
            color: white;
            margin-top: 12px;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow:
                0 4px 16px rgba(0, 122, 255, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, transparent 50%);
            border-radius: inherit;
            pointer-events: none;
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px) scale(1.02);
            box-shadow:
                0 8px 24px rgba(0, 122, 255, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        button:active:not(:disabled) {
            transform: translateY(0) scale(0.98);
        }

        button:disabled {
            background: var(--text-secondary);
            cursor: not-allowed;
            box-shadow: none;
            opacity: 0.6;
        }

        .btn-success {
            background: var(--success-color);
            box-shadow:
                0 4px 16px rgba(52, 199, 89, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .btn-success:hover:not(:disabled) {
            box-shadow:
                0 8px 24px rgba(52, 199, 89, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        .btn-secondary {
            background: var(--glass-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            box-shadow:
                0 2px 8px var(--shadow-light),
                inset 0 1px 0 rgba(255, 255, 255, 0.5);
        }

        .btn-secondary:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.95);
            box-shadow:
                0 4px 16px var(--shadow-medium),
                inset 0 1px 0 rgba(255, 255, 255, 0.7);
        }

        .status {
            padding: 18px 24px;
            border-radius: 16px;
            font-weight: 600;
            text-align: center;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            font-size: 16px;
            margin-bottom: 16px;
        }

        .status.disconnected {
            background: rgba(255, 59, 48, 0.1);
            border: 1px solid rgba(255, 59, 48, 0.2);
            color: var(--error-color);
        }

        .status.connected {
            background: rgba(52, 199, 89, 0.1);
            border: 1px solid rgba(52, 199, 89, 0.2);
            color: var(--success-color);
        }

        .hint {
            margin-top: 6px;
            font-size: 0.85rem;
            color: var(--text-color);
            opacity: 0.7;
        }

        .canvas-card header {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .toolbar {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 16px;
        }

        .color-picker {
            width: 52px;
            height: 52px;
            border-radius: 50%;
            border: none;
            padding: 0;
            cursor: pointer;
        }

        .slider-group {
            background: rgba(25, 118, 210, 0.08);
            border: 1px solid rgba(25, 118, 210, 0.15);
            border-radius: 12px;
            padding: 10px 14px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            font-size: 0.9rem;
        }

        .slider-group input[type="range"] {
            width: 100%;
        }

        .tool-button {
            width: 100%;
            background: rgba(25, 118, 210, 0.08);
            color: var(--text-color);
        }

        .tool-button.active {
            background: var(--primary-color);
            color: #fff;
        }

        .text-controls {
            display: none;
            margin-top: 16px;
            gap: 10px;
        }

        .text-controls input[type="text"] {
            flex: 1;
        }

        .canvas-wrapper {
            margin-top: 18px;
            padding: 18px;
            border-radius: 16px;
            background: rgba(15, 23, 42, 0.04);
            border: 1px dashed var(--border-color);
            display: flex;
            justify-content: center;
        }

        canvas {
            background: #ffffff;
            border-radius: 8px;
            border: 2px solid rgba(15, 23, 42, 0.1);
        }

        .upload-area {
            margin-top: 12px;
            padding: 18px;
            border-radius: 12px;
            border: 2px dashed var(--border-color);
            text-align: center;
            cursor: pointer;
            transition: border-color 0.2s ease, background 0.2s ease;
        }

        .upload-area.dragover {
            border-color: var(--primary-color);
            background: rgba(25, 118, 210, 0.08);
        }

        .log-card {
            margin-top: 24px;
        }

        #logArea {
            margin-top: 12px;
            background: #0b1729;
            color: #7cf29c;
            border-radius: 12px;
            padding: 16px;
            height: 220px;
            overflow-y: auto;
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            font-size: 0.85rem;
            white-space: pre-wrap;
        }

        @media (max-width: 980px) {
            .layout {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üè∑Ô∏è NEMR ESL Studio</h1>
            <p class="subtitle">Professional 2.9" Electronic Shelf Label Designer</p>
        </div>

        <div class="layout">
            <div class="card control-card">
                <h2>üì° Device Connection</h2>
                <div id="connectionStatus" class="status disconnected">‚ùå Not connected</div>
                <div id="speedStatus" class="status" style="margin-top: 8px; font-size: 0.9em; opacity: 0.8;">üöÄ Fast Mode</div>
                <button id="connectBtn" onclick="connectDevice()">üîó Connect to NEMR Device</button>

                <div class="form-group">
                    <label for="rotationSelect">Orientation</label>
                    <select id="rotationSelect">
                        <option value="0">Landscape (0¬∞)</option>
                        <option value="180">Flip 180¬∞</option>
                    </select>
                    <p class="hint">2.9" Ìå®ÎÑêÏùÄ Í∏∞Î≥∏Ï†ÅÏúºÎ°ú Í∞ÄÎ°úÎ™®ÎìúÏûÖÎãàÎã§. Í±∞Íæ∏Î°ú ÏÑ§ÏπòÌïú Í≤ΩÏö∞ 180¬∞Î•º ÏÇ¨Ïö©ÌïòÏÑ∏Ïöî.</p>
                </div>

                <div style="margin-top: 24px;">
                    <h3 style="margin-bottom: 16px; font-size: 1.1rem; color: var(--text-color);">üì§ Upload</h3>
                    <button id="uploadBtn" class="btn-success" onclick="uploadToDevice()" disabled>üì§ Upload to ESL</button>
                    <div id="uploadProgress" style="display:none; margin-top:16px;">
                        <div style="background:rgba(0,0,0,0.1); border-radius:12px; height:8px; overflow:hidden;">
                            <div id="progressBar" style="background:var(--success-color); height:100%; width:0%; transition:width 0.3s ease; border-radius:12px;"></div>
                        </div>
                        <p id="progressText" style="margin-top:8px; font-size:0.9rem; text-align:center; color: var(--text-secondary);">Ï§ÄÎπÑ Ï§ë...</p>
                    </div>
                </div>

                <div style="margin-top: 24px;">
                    <h3 style="margin-bottom: 16px; font-size: 1.1rem; color: var(--text-color);">üé® Canvas Actions</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <button onclick="undoCanvas()" id="undoBtn" disabled class="btn-secondary">‚Ü∂ Undo</button>
                        <button onclick="redoCanvas()" id="redoBtn" disabled class="btn-secondary">‚Ü∑ Redo</button>
                    </div>
                    <button onclick="addDemoLayout()" class="btn-secondary">‚ú® Sample Layout</button>
                    <button onclick="downloadCanvas()" class="btn-secondary">üíæ Download PNG</button>
                </div>

                <div style="margin-top: 24px; padding-top: 24px; border-top: 1px solid var(--border-color);">
                    <button onclick="clearCanvas()" style="background: var(--error-color); box-shadow: 0 4px 16px rgba(255, 59, 48, 0.2);">üóëÔ∏è Clear Canvas</button>
                    <button id="disconnectBtn" onclick="disconnectDevice()" style="display:none; background: var(--text-secondary); margin-top: 8px;">üîå Disconnect Device</button>
                </div>
            </div>

            <div class="card canvas-card">
                <h2>üé® Drawing Canvas</h2>
                <p class="hint">ÎÑ§Ïù¥Ìã∞Î∏å Canvas ÌÅ¨Í∏∞: 296 √ó 128 px (2.9" ESL Ìï¥ÏÉÅÎèÑ Í≥†Ï†ï)</p>

                <div id="uploadArea" class="upload-area" onclick="document.getElementById('fileInput').click()"
                     ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event)">
                    <strong>üìÅ Ïù¥ÎØ∏ÏßÄ Î∂àÎü¨Ïò§Í∏∞</strong>
                    <p>ÌÅ¥Î¶≠ÌïòÏó¨ ÏÑ†ÌÉùÌïòÍ±∞ÎÇò, Ïù¥ÎØ∏ÏßÄÎ•º ÎÅåÏñ¥Îã§ ÎÜìÏúºÏÑ∏Ïöî.</p>
                    <input type="file" id="fileInput" accept="image/*" onchange="loadImage(event)" style="display:none;">
                </div>

                <div class="toolbar">
                    <input type="color" id="colorPicker" class="color-picker" value="#000000" onchange="updateBrushColor(this.value)">

                    <div class="slider-group">
                        <span>Brush Size: <strong id="brushSizeValue">5</strong> px</span>
                        <input type="range" id="brushSize" min="1" max="40" value="5" oninput="updateBrushSize(this.value)">
                    </div>

                    <button id="brushBtn" class="tool-button active" onclick="setTool('brush')">üñåÔ∏è Brush</button>
                    <button id="eraserBtn" class="tool-button" onclick="setTool('eraser')">ü©π Eraser</button>
                    <button id="rectBtn" class="tool-button" onclick="addShape('rect')">‚¨ú Rectangle</button>
                    <button id="circleBtn" class="tool-button" onclick="addShape('circle')">‚≠ï Circle</button>
                    <button id="lineBtn" class="tool-button" onclick="addShape('line')">üìè Line</button>
                    <button id="textBtn" class="tool-button" onclick="setTool('text')">üìù Text</button>
                </div>

                <div class="text-controls" id="textControls">
                    <div style="display: flex; gap: 8px; align-items: center; margin-bottom: 8px;">
                        <input type="text" id="textInput" placeholder="ÌÖçÏä§Ìä∏Î•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî" value="NEMR ESL" style="flex: 1;">
                        <button onclick="commitText()" style="width: auto; padding: 8px 16px; margin: 0;">Ï∂îÍ∞Ä</button>
                    </div>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <label style="margin: 0; font-size: 0.9rem;">ÌÅ¨Í∏∞:</label>
                        <input type="range" id="fontSizeSlider" min="10" max="48" value="20" style="flex: 1;" oninput="updateFontSize(this.value)">
                        <span id="fontSizeValue" style="min-width: 35px; font-size: 0.9rem; font-weight: bold;">20px</span>
                    </div>
                    <input type="hidden" id="fontSize" value="20">
                </div>

                <div class="canvas-wrapper">
                    <canvas id="drawingCanvas" width="296" height="128"></canvas>
                </div>
            </div>
        </div>

        <div class="card log-card">
            <h2>üìù Activity Log</h2>
            <div id="logArea"></div>
        </div>
    </div>

    <script>
        const ESL_WIDTH = 296;
        const ESL_HEIGHT = 128;

        let canvas = null;
        let ctx = null;
        let currentTool = 'brush';
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let startX = 0;
        let startY = 0;
        let isShapeDrawing = false;
        let tempCanvas = null;
        let tempCtx = null;
        let canvasRect = null;
        let device = null;
        let cmdCharacteristic = null;
        let imgCharacteristic = null;

        // Adaptive speed control
        let transferMode = 'medium'; // Start with stable mode
        let retryAttempts = 0;
        let maxRetryAttempts = 2;

        let partMsgSize = 244;
        let partDataSize = 240;
        let payload = [];
        let gotAck = false;
        let currentAck = 0;
        let protocolStep = 0;
        let canvasHistory = [];
        let historyIndex = -1;
        let maxHistory = 50;

        document.addEventListener('DOMContentLoaded', () => {
            initCanvas();
            updateSpeedStatus(); // Initialize speed status display
            log('‚úÖ NEMR ESL Studio Ready ‚Äì Canvas initialised for 296√ó128');
            log('üí° Start creating your professional ESL design');

            // Add keyboard shortcuts
            document.addEventListener('keydown', handleKeyboard);
        });

        function handleKeyboard(e) {
            // Ctrl+Z for undo
            if (e.ctrlKey && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undoCanvas();
            }
            // Ctrl+Y or Ctrl+Shift+Z for redo
            if (e.ctrlKey && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                e.preventDefault();
                redoCanvas();
            }
            // Enter to add text when text tool is active
            if (e.key === 'Enter' && currentTool === 'text' && e.target.id === 'textInput') {
                e.preventDefault();
                commitText();
            }
        }


        function initCanvas() {
            canvas = document.getElementById('drawingCanvas');
            ctx = canvas.getContext('2d');

            // Cache canvas rect for performance
            canvasRect = canvas.getBoundingClientRect();

            // Update canvas rect on window resize
            window.addEventListener('resize', () => {
                canvasRect = canvas.getBoundingClientRect();
            });

            // Create temporary canvas for shape preview
            tempCanvas = document.createElement('canvas');
            tempCanvas.width = ESL_WIDTH;
            tempCanvas.height = ESL_HEIGHT;
            tempCtx = tempCanvas.getContext('2d');

            // Set canvas properties
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.lineWidth = 5;
            ctx.strokeStyle = '#000000';
            ctx.fillStyle = '#ffffff';

            // Fill background
            ctx.fillRect(0, 0, ESL_WIDTH, ESL_HEIGHT);

            // Add event listeners
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseout', handleMouseUp);

            // Touch events for mobile
            canvas.addEventListener('touchstart', handleTouch);
            canvas.addEventListener('touchmove', handleTouch);
            canvas.addEventListener('touchend', handleMouseUp);

            // Save initial state
            saveCanvasState();
        }

        function getCanvasCoordinates(clientX, clientY) {
            // Always get fresh rect to handle scroll changes
            const rect = canvas.getBoundingClientRect();
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function handleMouseDown(e) {
            const coords = getCanvasCoordinates(e.clientX, e.clientY);
            startX = coords.x;
            startY = coords.y;
            lastX = startX;
            lastY = startY;

            if (currentTool === 'text') {
                addTextAt(startX, startY);
                return;
            }

            if (currentTool === 'rect' || currentTool === 'circle' || currentTool === 'line') {
                isShapeDrawing = true;
                // Save current canvas state for preview
                tempCtx.drawImage(canvas, 0, 0);
                return;
            }

            if (currentTool === 'brush' || currentTool === 'eraser') {
                isDrawing = true;
                ctx.beginPath();
                ctx.moveTo(startX, startY);
            }
        }

        function handleMouseMove(e) {
            const coords = getCanvasCoordinates(e.clientX, e.clientY);
            const currentX = coords.x;
            const currentY = coords.y;

            if (isShapeDrawing && (currentTool === 'rect' || currentTool === 'circle' || currentTool === 'line')) {
                // Clear canvas and redraw original content
                ctx.clearRect(0, 0, ESL_WIDTH, ESL_HEIGHT);
                ctx.drawImage(tempCanvas, 0, 0);

                // Draw preview shape
                const color = document.getElementById('colorPicker').value;
                const lineWidth = parseInt(document.getElementById('brushSize').value, 10);
                ctx.strokeStyle = color;
                ctx.lineWidth = lineWidth;

                if (currentTool === 'rect') {
                    const width = currentX - startX;
                    const height = currentY - startY;
                    ctx.strokeRect(startX, startY, width, height);
                } else if (currentTool === 'circle') {
                    const radius = Math.sqrt(Math.pow(currentX - startX, 2) + Math.pow(currentY - startY, 2));
                    ctx.beginPath();
                    ctx.arc(startX, startY, radius, 0, 2 * Math.PI);
                    ctx.stroke();
                } else if (currentTool === 'line') {
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(currentX, currentY);
                    ctx.stroke();
                }
                return;
            }

            if (isDrawing && (currentTool === 'brush' || currentTool === 'eraser')) {
                ctx.lineTo(currentX, currentY);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(currentX, currentY);
            }

            lastX = currentX;
            lastY = currentY;
        }

        function handleMouseUp() {
            if (isShapeDrawing) {
                isShapeDrawing = false;
                // Shape is already drawn from preview, just save state
                setTimeout(() => saveCanvasState(), 50);
                log(`‚ú® Added ${currentTool}`);
                return;
            }

            if (isDrawing) {
                isDrawing = false;
                setTimeout(() => saveCanvasState(), 50);
            }
        }

        function handleTouch(e) {
            e.preventDefault();
            const touch = e.touches[0];

            if (e.type === 'touchstart') {
                handleMouseDown({
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
            } else if (e.type === 'touchmove') {
                handleMouseMove({
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
            } else if (e.type === 'touchend') {
                handleMouseUp();
            }
        }

        function setTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-button').forEach(btn => btn.classList.remove('active'));

            switch (tool) {
                case 'brush':
                    document.getElementById('brushBtn').classList.add('active');
                    ctx.strokeStyle = document.getElementById('colorPicker').value;
                    ctx.lineWidth = parseInt(document.getElementById('brushSize').value, 10);
                    ctx.globalCompositeOperation = 'source-over';
                    hideTextControls();
                    log('üñåÔ∏è Brush enabled');
                    break;
                case 'eraser':
                    document.getElementById('eraserBtn').classList.add('active');
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.lineWidth = parseInt(document.getElementById('brushSize').value, 10);
                    hideTextControls();
                    log('üßΩ Eraser enabled');
                    break;
                case 'text':
                    document.getElementById('textBtn').classList.add('active');
                    showTextControls();
                    log('üìù Click canvas to place text');
                    break;
                case 'rect':
                    document.getElementById('rectBtn').classList.add('active');
                    hideTextControls();
                    log('‚¨ú Rectangle tool - drag to draw');
                    break;
                case 'circle':
                    document.getElementById('circleBtn').classList.add('active');
                    hideTextControls();
                    log('‚≠ï Circle tool - drag to draw');
                    break;
                case 'line':
                    document.getElementById('lineBtn').classList.add('active');
                    hideTextControls();
                    log('üìè Line tool - drag to draw');
                    break;
                default:
                    hideTextControls();
                    break;
            }
        }

        function addShape(type) {
            setTool(type);
            // Now shapes are drawn interactively - no need for fixed shapes
        }

        function showTextControls() {
            document.getElementById('textControls').style.display = 'flex';
        }

        function hideTextControls() {
            document.getElementById('textControls').style.display = 'none';
        }

        function commitText() {
            if (currentTool !== 'text') {
                setTool('text');
            }
            log('‚ÑπÔ∏è ÌÖçÏä§Ìä∏Î•º Ï∂îÍ∞ÄÌïòÎ†§Î©¥ Ï∫îÎ≤ÑÏä§Î•º ÌÅ¥Î¶≠ÌïòÏÑ∏Ïöî');
        }

        function addTextAt(x, y) {
            const value = document.getElementById('textInput').value.trim();
            if (!value) {
                log('‚ùå ÌÖçÏä§Ìä∏ ÎÇ¥Ïö©ÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî');
                return;
            }
            const fontSize = parseInt(document.getElementById('fontSize').value, 10) || 20;
            const color = document.getElementById('colorPicker').value;

            ctx.fillStyle = color;
            ctx.font = `${fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(value, x, y);

            saveCanvasState();
            log(`üìù ÌÖçÏä§Ìä∏ Ï∂îÍ∞Ä: "${value}" @ (${Math.round(x)}, ${Math.round(y)})`);
        }

        function updateBrushColor(color) {
            if (currentTool === 'brush') {
                ctx.strokeStyle = color;
            }
        }

        function updateBrushSize(size) {
            const px = parseInt(size, 10);
            document.getElementById('brushSizeValue').textContent = px;
            ctx.lineWidth = px;
        }

        function updateFontSize(size) {
            const px = parseInt(size, 10);
            document.getElementById('fontSizeValue').textContent = px + 'px';
            document.getElementById('fontSize').value = px;
        }

        function clearCanvas() {
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, ESL_WIDTH, ESL_HEIGHT);
            saveCanvasState();
            log('üóëÔ∏è Canvas cleared');
        }

        function saveCanvasState() {
            // Remove future history if we're not at the end
            if (historyIndex < canvasHistory.length - 1) {
                canvasHistory = canvasHistory.slice(0, historyIndex + 1);
            }

            // Add current state (use getImageData for better performance)
            const imageData = ctx.getImageData(0, 0, ESL_WIDTH, ESL_HEIGHT);
            canvasHistory.push(imageData);

            // Limit history size
            if (canvasHistory.length > maxHistory) {
                canvasHistory.shift();
            } else {
                historyIndex++;
            }

            updateUndoRedoButtons();
        }

        function undoCanvas() {
            if (historyIndex > 0) {
                historyIndex--;
                loadCanvasState(canvasHistory[historyIndex]);
                updateUndoRedoButtons();
                log('‚Ü∂ Undo applied');
            }
        }

        function redoCanvas() {
            if (historyIndex < canvasHistory.length - 1) {
                historyIndex++;
                loadCanvasState(canvasHistory[historyIndex]);
                updateUndoRedoButtons();
                log('‚Ü∑ Redo applied');
            }
        }

        function loadCanvasState(imageData) {
            ctx.putImageData(imageData, 0, 0);
        }

        function updateUndoRedoButtons() {
            document.getElementById('undoBtn').disabled = historyIndex <= 0;
            document.getElementById('redoBtn').disabled = historyIndex >= canvasHistory.length - 1;
        }

        function addDemoLayout() {
            clearCanvas();

            // Draw header text
            ctx.fillStyle = '#000000';
            ctx.font = 'bold 26px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ÌöåÏùòÏã§ ÏïàÎÇ¥', ESL_WIDTH / 2, 28);

            // Draw subtitle
            ctx.fillStyle = '#333333';
            ctx.font = '16px Arial';
            ctx.fillText('NEMR Ï†ÑÏûêÍ∞ÄÍ≤©ÌëúÏãúÍ∏∞ (2.9")', ESL_WIDTH / 2, 56);

            // Draw box
            ctx.strokeStyle = '#1976d2';
            ctx.lineWidth = 2;
            ctx.fillStyle = 'rgba(25,118,210,0.05)';
            ctx.fillRect(16, 72, ESL_WIDTH - 32, 40);
            ctx.strokeRect(16, 72, ESL_WIDTH - 32, 40);

            // Draw time
            ctx.fillStyle = '#000000';
            ctx.font = '20px Arial';
            ctx.fillText('14:30 ~ 15:30', ESL_WIDTH / 2, 92);

            saveCanvasState();
            log('‚ú® Sample layout inserted');
        }

        function downloadCanvas() {
            const dataURL = canvas.toDataURL('image/png');
            const a = document.createElement('a');
            a.href = dataURL;
            a.download = 'nemr-esl-2.9.png';
            a.click();
            log('üíæ Canvas downloaded');
        }

        function loadImage(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    const scale = Math.min(
                        ESL_WIDTH / img.width,
                        ESL_HEIGHT / img.height
                    );
                    const scaledWidth = img.width * scale;
                    const scaledHeight = img.height * scale;
                    const x = (ESL_WIDTH - scaledWidth) / 2;
                    const y = (ESL_HEIGHT - scaledHeight) / 2;

                    ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
                    saveCanvasState();
                    log(`üì∑ Image loaded: ${file.name}`);
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function handleDragOver(event) {
            event.preventDefault();
            document.getElementById('uploadArea').classList.add('dragover');
        }

        function handleDragLeave(event) {
            event.preventDefault();
            document.getElementById('uploadArea').classList.remove('dragover');
        }

        function handleDrop(event) {
            event.preventDefault();
            document.getElementById('uploadArea').classList.remove('dragover');
            const files = event.dataTransfer.files;
            if (files && files.length > 0 && files[0].type.startsWith('image/')) {
                loadImage({ target: { files } });
            }
        }

        function updateConnectionStatus(connected) {
            const status = document.getElementById('connectionStatus');
            const connectBtn = document.getElementById('connectBtn');
            const disconnectBtn = document.getElementById('disconnectBtn');
            const uploadBtn = document.getElementById('uploadBtn');

            if (connected) {
                status.classList.remove('disconnected');
                status.classList.add('connected');
                status.textContent = `‚úÖ Connected to ${device.name}`;
                connectBtn.textContent = 'üîÑ Reconnect';
                disconnectBtn.style.display = 'block';
                uploadBtn.disabled = false;
            } else {
                status.classList.add('disconnected');
                status.classList.remove('connected');
                status.textContent = '‚ùå Not connected';
                connectBtn.textContent = 'üîó Connect to NEMR Device';
                disconnectBtn.style.display = 'none';
                uploadBtn.disabled = true;
            }
        }

        function updateSpeedStatus() {
            const speedStatus = document.getElementById('speedStatus');
            const config = getSpeedConfig();
            const modeEmoji = {
                'fast': 'üì∂',
                'medium': '‚ö°',
                'slow': 'üêå',
                'ultra': 'üõ°Ô∏è'
            };

            speedStatus.textContent = `${modeEmoji[transferMode]} ${config.name}`;
        }

        async function connectDevice() {
            try {
                if (device && device.gatt.connected) {
                    log('‚úÖ Already connected');
                    return;
                }

                if (device) {
                    // Try to reconnect to existing device
                    log('üîÑ Reconnecting to saved device...');
                    try {
                        const server = await device.gatt.connect();
                        log(`üîó Reconnected to GATT server (${device.name})`);

                        // Re-optimize transfer settings for this device
                        optimizeForDevice(device.name);

                        await setupCharacteristics(server);
                        return;
                    } catch (reconnectError) {
                        log('‚ùå Reconnection failed, searching for new device...');
                        device = null;
                    }
                }

                log('üîç Searching for NEMR Bluetooth devices...');
                device = await navigator.bluetooth.requestDevice({
                    filters: [{ namePrefix: 'NEMR' }],
                    optionalServices: ['0000fef0-0000-1000-8000-00805f9b34fb']
                });

                const server = await device.gatt.connect();
                log(`üîó Connected to GATT server (${device.name})`);

                // Optimize transfer settings for this specific device
                optimizeForDevice(device.name);

                await setupCharacteristics(server);

            } catch (error) {
                log(`‚ùå Connection failed: ${error.message}`);
                updateConnectionStatus(false);
            }
        }

        async function setupCharacteristics(server) {
            const service = await server.getPrimaryService('0000fef0-0000-1000-8000-00805f9b34fb');
            cmdCharacteristic = await service.getCharacteristic('0000fef1-0000-1000-8000-00805f9b34fb');
            imgCharacteristic = await service.getCharacteristic('0000fef2-0000-1000-8000-00805f9b34fb');

            await cmdCharacteristic.startNotifications();
            cmdCharacteristic.addEventListener('characteristicvaluechanged', handleCommandResponse);

            // Add disconnect listener (remove old ones first)
            device.removeEventListener('gattserverdisconnected', handleDeviceDisconnected);
            device.addEventListener('gattserverdisconnected', handleDeviceDisconnected);

            updateConnectionStatus(true);
            log('‚úÖ Ready to upload');
        }

        function disconnectDevice() {
            if (device && device.gatt.connected) {
                device.gatt.disconnect();
            }
            updateConnectionStatus(false);
            log('üîå Disconnected');
        }

        function handleDeviceDisconnected() {
            log('‚ö†Ô∏è Device disconnected');
            updateConnectionStatus(false);
            showUploadProgress(false);

            // Don't clear device reference immediately - allow reconnection
            setTimeout(() => {
                if (device && !device.gatt.connected) {
                    log('üí° Ready to reconnect - click Connect button');
                }
            }, 2000);
        }

        function handleCommandResponse(event) {
            const data = new Uint8Array(event.target.value.buffer);
            const op = data[0];

            if (op === 0x01 && data.length >= 3) {
                partMsgSize = data[1] | (data[2] << 8);
                partDataSize = partMsgSize >= 4 ? (partMsgSize - 4) : 240;
                protocolStep = 1;
                log(`üìã Chunk size negotiated ‚Üí ${partDataSize} bytes`);
            } else if (op === 0x02) {
                protocolStep = 2;
                log('üì® Size command acknowledged');
            } else if (op === 0x05 && data.length >= 2) {
                const status = data[1];
                if (status === 0x08) {
                    protocolStep = 99;
                    log('‚úÖ Device confirmed image refresh');
                } else if (status === 0x00 && data.length >= 6) {
                    currentAck = data[2] | (data[3] << 8) | (data[4] << 16) | (data[5] << 24);
                    gotAck = true;
                    log(`üì® ACK received for part ${currentAck}`);
                } else {
                    protocolStep = -1;
                    log(`‚ùå Device reported error status 0x${status.toString(16)}`);
                }
            } else {
                log(`üì® CMD 0x${op.toString(16).padStart(2, '0')} (${data.length} bytes)`);
            }
        }

        async function sendCommand(bytes) {
            try {
                await cmdCharacteristic.writeValue(new Uint8Array(bytes));
                return true;
            } catch (error) {
                log(`‚ùå Command send failed: ${error.message}`);
                return false;
            }
        }

        async function sendImagePart(partIndex) {
            const offset = partIndex * partDataSize;
            if (offset >= payload.length) {
                return true;
            }
            const chunkLength = Math.min(partDataSize, payload.length - offset);
            const packet = new Uint8Array(4 + chunkLength);
            packet[0] = partIndex & 0xff;
            packet[1] = (partIndex >> 8) & 0xff;
            packet[2] = (partIndex >> 16) & 0xff;
            packet[3] = (partIndex >> 24) & 0xff;
            packet.set(payload.slice(offset, offset + chunkLength), 4);
            try {
                await imgCharacteristic.writeValue(packet);
                return true;
            } catch (error) {
                log(`‚ùå Data part send failed: ${error.message}`);
                return false;
            }
        }

        async function uploadToDevice() {
            if (!cmdCharacteristic || !imgCharacteristic) {
                log('‚ùå Connect to a device first');
                return;
            }

            try {
                showUploadProgress(true);
                updateProgress(0, 'Ïù¥ÎØ∏ÏßÄ Ï§ÄÎπÑ Ï§ë...');

                const imageData = prepareImageData();
                payload = convertToESLBitmap(imageData);
                log(`üßÆ Prepared payload (${payload.length} bytes)`);

                // Get current speed configuration
                const speedConfig = getSpeedConfig();
                log(`üöÄ Using ${speedConfig.name} (mainDelay: ${speedConfig.mainDelay}ms)`);

                updateProgress(10, 'Ìï∏ÎìúÏÖ∞Ïù¥ÌÅ¨ ÏãúÏûë...');
                protocolStep = 0;
                gotAck = false;
                currentAck = 0;

                if (!await sendCommand([0x01])) {
                    showUploadProgress(false);
                    return;
                }

                for (let i = 0; i < speedConfig.timeout; i++) {
                    if (protocolStep >= 1) break;
                    await delay(speedConfig.handshakeDelay);
                }
                if (protocolStep < 1) {
                    log('‚ùå Handshake (0x01) timeout');
                    if (await attemptSpeedFallback('handshake_timeout')) {
                        return await uploadToDevice(); // Retry with slower speed
                    }
                    showUploadProgress(false);
                    return;
                }

                updateProgress(20, 'ÌÅ¨Í∏∞ Ï†ïÎ≥¥ Ï†ÑÏÜ° Ï§ë...');
                const sizeMsg = new Uint8Array(8);
                sizeMsg[0] = 0x02;
                const total = payload.length;
                sizeMsg[1] = total & 0xff;
                sizeMsg[2] = (total >> 8) & 0xff;
                sizeMsg[3] = (total >> 16) & 0xff;
                sizeMsg[4] = (total >> 24) & 0xff;
                if (!await sendCommand(sizeMsg)) {
                    showUploadProgress(false);
                    return;
                }
                await delay(speedConfig.commandDelay);

                if (!await sendCommand([0x03])) {
                    showUploadProgress(false);
                    return;
                }

                const totalParts = Math.ceil(payload.length / partDataSize);
                updateProgress(30, `Îç∞Ïù¥ÌÑ∞ Ï†ÑÏÜ° ÏãúÏûë (${totalParts} Ìå®ÌÇ∑)...`);
                log(`üöö Sending ${totalParts} packets‚Ä¶`);

                let currentPart = 0;
                let lastAck = -1;
                let stallCounter = 0;
                let failureAtPacket = -1;

                // Wait before starting data transfer
                await delay(speedConfig.preTransferDelay);

                // Send first packet
                if (!await sendImagePart(currentPart)) {
                    showUploadProgress(false);
                    return;
                }

                // Send next packet if dual sending is enabled
                if (speedConfig.sendDual) {
                    currentPart++;
                    if (currentPart < totalParts) {
                        await sendImagePart(currentPart);
                    }
                }

                while (currentPart <= totalParts && stallCounter < speedConfig.timeout) {
                    await delay(speedConfig.mainDelay);

                    if (protocolStep === 99) {
                        updateProgress(100, 'ÏóÖÎ°úÎìú ÏôÑÎ£å!');
                        log('üéâ Upload complete');
                        setTimeout(() => showUploadProgress(false), 2000);
                        return;
                    }
                    if (protocolStep === -1) {
                        log('‚ùå Device aborted transfer');
                        showUploadProgress(false);
                        return;
                    }

                    if (gotAck && currentAck !== lastAck) {
                        lastAck = currentAck;
                        stallCounter = 0;

                        if (currentAck >= totalParts) {
                            log('‚úÖ All parts acknowledged');
                            break;
                        }

                        // Send the next packet after the acknowledged one
                        const nextPart = currentAck + 1;
                        if (nextPart < totalParts) {
                            currentPart = nextPart;
                            if (!await sendImagePart(currentPart)) {
                                showUploadProgress(false);
                                return;
                            }
                        }

                        // Update progress bar
                        const progressPercent = 30 + (currentAck / totalParts) * 60; // 30-90%
                        updateProgress(progressPercent, `Ï†ÑÏÜ° Ï§ë... ${currentAck + 1}/${totalParts}`);

                        if (currentAck % 4 === 0) {
                            log(`üìä Progress ${currentAck + 1}/${totalParts}`);
                        }

                        gotAck = false;
                    } else {
                        stallCounter++;
                        if (stallCounter % speedConfig.retryInterval === 0) {
                            log(`‚è≥ Still waiting for ACK‚Ä¶ retry part ${currentPart}`);
                            if (!await sendImagePart(currentPart)) {
                                showUploadProgress(false);
                                return;
                            }
                        }
                    }
                }

                // Check if we failed at a specific packet and attempt fallback
                if (stallCounter >= speedConfig.timeout) {
                    failureAtPacket = currentPart;
                    log(`‚ö†Ô∏è Transfer stalled at packet ${failureAtPacket}/${totalParts}`);
                    if (await attemptSpeedFallback('transfer_stall', failureAtPacket)) {
                        return await uploadToDevice(); // Retry with slower speed
                    }
                    log('‚ùå Transfer failed even with slowest speed');
                    showUploadProgress(false);
                    return;
                }

                if (protocolStep === 99) {
                    updateProgress(100, 'ESL ÏÉàÎ°úÍ≥†Ïπ® ÏôÑÎ£å!');
                    log('‚úÖ ESL refresh complete');
                    setTimeout(() => {
                        showUploadProgress(false);
                        // Auto-reconnect after successful transfer
                        setTimeout(() => {
                            if (!device || !device.gatt.connected) {
                                log('üîÑ Auto-reconnecting...');
                                connectDevice();
                            }
                        }, 1000);
                    }, 2000);
                } else {
                    log('‚ö†Ô∏è Transfer ended without final confirmation');
                    showUploadProgress(false);
                }
            } catch (error) {
                log(`‚ùå Upload failed: ${error.message}`);
                showUploadProgress(false);
            }
        }

        function showUploadProgress(show) {
            document.getElementById('uploadProgress').style.display = show ? 'block' : 'none';
            document.getElementById('uploadBtn').disabled = show;
        }

        function updateProgress(percent, text) {
            document.getElementById('progressBar').style.width = `${percent}%`;
            document.getElementById('progressText').textContent = text;
        }

        function prepareImageData() {
            const rotation = parseInt(document.getElementById('rotationSelect').value, 10);
            if (rotation === 180) {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = ESL_WIDTH;
                tempCanvas.height = ESL_HEIGHT;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.translate(ESL_WIDTH, ESL_HEIGHT);
                tempCtx.rotate(Math.PI);
                tempCtx.drawImage(canvas, 0, 0);
                log('üîÑ Applied 180¬∞ rotation for upload');
                return tempCtx.getImageData(0, 0, ESL_WIDTH, ESL_HEIGHT);
            }

            return ctx.getImageData(0, 0, ESL_WIDTH, ESL_HEIGHT);
        }

        function convertToESLBitmap(imageData) {
            const { width, height, data } = imageData;
            const bytesPerRow = Math.ceil(width / 8);
            const mirrorX = true;

            const bwBuffer = new Uint8Array(bytesPerRow * height);
            const redBuffer = new Uint8Array(bytesPerRow * height);
            bwBuffer.fill(0xff);
            redBuffer.fill(0xff);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idxRGBA = (y * width + x) * 4;
                    const r = data[idxRGBA];
                    const g = data[idxRGBA + 1];
                    const b = data[idxRGBA + 2];

                    const column = Math.floor(x / 8);
                    const bitMask = 0x80 >> (x % 8);
                    const idx = y * bytesPerRow + column;

                    const isRed = r > 150 && r > g + b && (r + g + b) < 600;
                    if (isRed) {
                        redBuffer[idx] &= ~bitMask;
                        bwBuffer[idx] |= bitMask;
                        continue;
                    }

                    const gray = (0.299 * r + 0.587 * g + 0.114 * b);
                    if (gray > 160) {
                        bwBuffer[idx] |= bitMask; // white
                    } else {
                        bwBuffer[idx] &= ~bitMask; // black
                    }
                }
            }

            const packed = [];
            const bytesPerColumn = Math.ceil(height / 8);

            const packPlane = (buffer, oneIsWhite) => {
                for (let x = 0; x < width; x++) {
                    const sourceX = mirrorX ? (width - 1 - x) : x;
                    for (let byteIndex = 0; byteIndex < bytesPerColumn; byteIndex++) {
                        let outByte = 0;
                        for (let bit = 0; bit < 8; bit++) {
                            const y = byteIndex * 8 + bit;
                            if (y >= height) continue;
                            const baseIndex = y * bytesPerRow + Math.floor(sourceX / 8);
                            const mask = 0x80 >> (sourceX % 8);
                            const bitIsOne = (buffer[baseIndex] & mask) !== 0;
                            const eslBit = oneIsWhite ? (bitIsOne ? 1 : 0) : (bitIsOne ? 0 : 1);
                            if (eslBit) {
                                outByte |= (1 << (7 - bit));
                            }
                        }
                        packed.push(outByte);
                    }
                }
            };

            packPlane(bwBuffer, true);
            packPlane(redBuffer, false);

            return packed;
        }

        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function getSpeedConfig() {
            switch(transferMode) {
                case 'fast':
                    return {
                        mainDelay: 50,
                        handshakeDelay: 50,
                        commandDelay: 100,
                        preTransferDelay: 200,
                        retryInterval: 50,
                        timeout: 200,
                        sendDual: false,
                        name: 'Standard Mode'
                    };
                case 'medium':
                    return {
                        mainDelay: 75,
                        handshakeDelay: 75,
                        commandDelay: 150,
                        preTransferDelay: 300,
                        retryInterval: 75,
                        timeout: 250,
                        sendDual: false,
                        name: 'Stable Mode'
                    };
                case 'slow':
                    return {
                        mainDelay: 100,
                        handshakeDelay: 100,
                        commandDelay: 200,
                        preTransferDelay: 500,
                        retryInterval: 100,
                        timeout: 300,
                        sendDual: false,
                        name: 'Compatible Mode'
                    };
                case 'ultra':
                    return {
                        mainDelay: 150,
                        handshakeDelay: 150,
                        commandDelay: 500,
                        preTransferDelay: 1000,
                        retryInterval: 150,
                        timeout: 400,
                        sendDual: false,
                        name: 'Ultra Compatible'
                    };
            }
        }

        function fallbackToSlowerMode() {
            if (transferMode === 'fast') {
                transferMode = 'medium';
                log('üîÑ Switching to Medium speed mode...');
                updateSpeedStatus();
                return true;
            } else if (transferMode === 'medium') {
                transferMode = 'slow';
                log('üîÑ Switching to Slow speed mode for compatibility...');
                updateSpeedStatus();
                return true;
            } else if (transferMode === 'slow') {
                transferMode = 'ultra';
                log('üîÑ Switching to Ultra Slow mode (ATC1441 pattern)...');
                updateSpeedStatus();
                return true;
            }
            return false; // Already at slowest mode
        }

        async function attemptSpeedFallback(reason, packet = null) {
            const packetInfo = packet !== null ? ` at packet ${packet}` : '';
            log(`‚ö†Ô∏è Transfer failed (${reason}${packetInfo})`);

            if (fallbackToSlowerMode()) {
                const config = getSpeedConfig();
                log(`üîÑ Retrying with ${config.name}...`);
                await delay(500); // Brief pause before retry
                return true;
            } else {
                // If already at slowest mode, try reconnecting (atc1441 pattern)
                log('‚ö†Ô∏è Already using slowest mode - attempting device reconnection...');
                try {
                    if (device && device.gatt.connected) {
                        await device.gatt.disconnect();
                        log('üîå Disconnected from device');
                        await delay(300); // 300ms delay like atc1441

                        const server = await device.gatt.connect();
                        log(`üîó Reconnected to GATT server (${device.name})`);
                        await setupCharacteristics(server);

                        log('üîÑ Attempting upload with fresh connection...');
                        await delay(500);
                        return true; // Try one more time with fresh connection
                    }
                } catch (reconnectError) {
                    log(`‚ùå Reconnection failed: ${reconnectError.message}`);
                }

                log('‚ùå Device may be incompatible or have hardware issues');
                return false;
            }
        }

        function optimizeForDevice(deviceName) {
            // Device-specific optimization profiles
            const deviceProfile = getDeviceProfile(deviceName);

            if (deviceProfile) {
                transferMode = deviceProfile.recommendedMode;
                log(`üéØ Applied ${deviceProfile.name} profile (${deviceProfile.recommendedMode} mode)`);

                if (deviceProfile.notes) {
                    log(`‚ÑπÔ∏è ${deviceProfile.notes}`);
                }
            } else {
                // Default for unknown devices - start conservative
                transferMode = 'medium';
                log('üîß Using Medium mode as default for unknown device');
            }

            updateSpeedStatus();
        }

        function getDeviceProfile(deviceName) {
            const name = deviceName?.toLowerCase() || '';

            // All NEMR devices start with stable medium mode
            if (name.includes('nemr')) {
                return {
                    name: 'NEMR ESL Profile',
                    recommendedMode: 'medium',
                    notes: 'Stable mode for reliable transfers'
                };
            }

            return null; // Unknown device
        }

        function log(message) {
            const logArea = document.getElementById('logArea');
            const stamp = new Date().toLocaleTimeString();
            logArea.textContent += `[${stamp}] ${message}\n`;
            logArea.scrollTop = logArea.scrollHeight;
        }

        if (!navigator.bluetooth) {
            log('‚ùå This browser does not support Web Bluetooth. Use Chrome or Edge.');
            document.getElementById('connectBtn').disabled = true;
        } else {
            log('üß≠ Web Bluetooth available');
        }
    </script>
</body>
</html>
