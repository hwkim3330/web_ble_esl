<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEMR 2.9\" ESL Uploader</title>
    <style>
        :root {
            --primary-color: #007AFF;
            --secondary-color: #5AC8FA;
            --success-color: #34C759;
            --error-color: #FF3B30;
            --warning-color: #FF9500;
            --bg-color: #F2F2F7;
            --card-bg: rgba(255, 255, 255, 0.9);
            --glass-bg: rgba(255, 255, 255, 0.85);
            --text-color: #1D1D1F;
            --text-secondary: #6D6D73;
            --border-color: rgba(0, 0, 0, 0.1);
            --shadow-light: rgba(0, 0, 0, 0.04);
            --shadow-medium: rgba(0, 0, 0, 0.08);
            --shadow-heavy: rgba(0, 0, 0, 0.12);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #F2F2F7 0%, #E5E5EA 100%);
            color: var(--text-color);
            min-height: 100vh;
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 24px;
        }

        .card {
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 20px;
            border: 1px solid var(--border-color);
            box-shadow:
                0 8px 32px var(--shadow-light),
                0 1px 2px var(--shadow-medium),
                inset 0 1px 0 rgba(255, 255, 255, 0.5);
            padding: 28px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .card:hover {
            transform: translateY(-2px);
            box-shadow:
                0 12px 40px var(--shadow-medium),
                0 4px 8px var(--shadow-light),
                inset 0 1px 0 rgba(255, 255, 255, 0.6);
        }

        .header {
            text-align: center;
            margin-bottom: 32px;
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 8px;
            letter-spacing: -0.02em;
        }

        .subtitle {
            font-size: 1.1rem;
            color: var(--text-secondary);
            font-weight: 400;
        }

        .layout {
            display: grid;
            grid-template-columns: 320px 1fr;
            gap: 24px;
        }

        .form-group {
            margin-top: 18px;
        }

        label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
        }

        select, input[type="number"], input[type="text"] {
            width: 100%;
            padding: 10px 12px;
            border-radius: 10px;
            border: 1px solid var(--border-color);
            background: var(--card-bg);
            color: var(--text-color);
            font-size: 15px;
        }

        button {
            width: 100%;
            padding: 16px 24px;
            border-radius: 16px;
            border: none;
            font-weight: 600;
            font-size: 16px;
            cursor: pointer;
            background: var(--primary-color);
            color: white;
            margin-top: 12px;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow:
                0 4px 16px rgba(0, 122, 255, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, transparent 50%);
            border-radius: inherit;
            pointer-events: none;
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px) scale(1.02);
            box-shadow:
                0 8px 24px rgba(0, 122, 255, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        button:active:not(:disabled) {
            transform: translateY(0) scale(0.98);
        }

        button:disabled {
            background: var(--text-secondary);
            cursor: not-allowed;
            box-shadow: none;
            opacity: 0.6;
        }

        .btn-success {
            background: var(--success-color);
            box-shadow:
                0 4px 16px rgba(52, 199, 89, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .btn-success:hover:not(:disabled) {
            box-shadow:
                0 8px 24px rgba(52, 199, 89, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        .btn-secondary {
            background: var(--glass-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            box-shadow:
                0 2px 8px var(--shadow-light),
                inset 0 1px 0 rgba(255, 255, 255, 0.5);
        }

        .btn-secondary:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.95);
            box-shadow:
                0 4px 16px var(--shadow-medium),
                inset 0 1px 0 rgba(255, 255, 255, 0.7);
        }

        .status {
            padding: 18px 24px;
            border-radius: 16px;
            font-weight: 600;
            text-align: center;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            font-size: 16px;
            margin-bottom: 16px;
        }

        .status.disconnected {
            background: rgba(255, 59, 48, 0.1);
            border: 1px solid rgba(255, 59, 48, 0.2);
            color: var(--error-color);
        }

        .status.connected {
            background: rgba(52, 199, 89, 0.1);
            border: 1px solid rgba(52, 199, 89, 0.2);
            color: var(--success-color);
        }

        .hint {
            margin-top: 6px;
            font-size: 0.85rem;
            color: var(--text-color);
            opacity: 0.7;
        }

        .canvas-card header {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .toolbar {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 16px;
        }

        .color-picker {
            width: 52px;
            height: 52px;
            border-radius: 50%;
            border: none;
            padding: 0;
            cursor: pointer;
        }

        .slider-group {
            background: rgba(25, 118, 210, 0.08);
            border: 1px solid rgba(25, 118, 210, 0.15);
            border-radius: 12px;
            padding: 10px 14px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            font-size: 0.9rem;
        }

        .slider-group input[type="range"] {
            width: 100%;
        }

        .tool-button {
            width: 100%;
            background: rgba(25, 118, 210, 0.08);
            color: var(--text-color);
        }

        .tool-button.active {
            background: var(--primary-color);
            color: #fff;
        }

        .text-controls {
            display: none;
            margin-top: 16px;
            gap: 10px;
        }

        .text-controls input[type="text"] {
            flex: 1;
        }

        .canvas-wrapper {
            margin-top: 18px;
            padding: 18px;
            border-radius: 16px;
            background: rgba(15, 23, 42, 0.04);
            border: 1px dashed var(--border-color);
            display: flex;
            justify-content: center;
        }

        canvas {
            background: #ffffff;
            border-radius: 8px;
            border: 2px solid rgba(15, 23, 42, 0.1);
        }

        .upload-area {
            margin-top: 12px;
            padding: 18px;
            border-radius: 12px;
            border: 2px dashed var(--border-color);
            text-align: center;
            cursor: pointer;
            transition: border-color 0.2s ease, background 0.2s ease;
        }

        .upload-area.dragover {
            border-color: var(--primary-color);
            background: rgba(25, 118, 210, 0.08);
        }

        .log-card {
            margin-top: 24px;
        }

        #logArea {
            margin-top: 12px;
            background: #0b1729;
            color: #7cf29c;
            border-radius: 12px;
            padding: 16px;
            height: 220px;
            overflow-y: auto;
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            font-size: 0.85rem;
            white-space: pre-wrap;
        }

        @media (max-width: 980px) {
            .layout {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ·ï¸ NEMR ESL Studio</h1>
            <p class="subtitle">Professional 2.9" Electronic Shelf Label Designer</p>
        </div>

        <div class="layout">
            <div class="card control-card">
                <h2>ğŸ“¡ Device Connection</h2>
                <div id="connectionStatus" class="status disconnected">âŒ Not connected</div>
                <button id="connectBtn" onclick="connectDevice()">ğŸ”— Connect to NEMR Device</button>

                <div class="form-group">
                    <label for="rotationSelect">Orientation</label>
                    <select id="rotationSelect">
                        <option value="0">Landscape (0Â°)</option>
                        <option value="180">Flip 180Â°</option>
                    </select>
                    <p class="hint">2.9" íŒ¨ë„ì€ ê¸°ë³¸ì ìœ¼ë¡œ ê°€ë¡œëª¨ë“œì…ë‹ˆë‹¤. ê±°ê¾¸ë¡œ ì„¤ì¹˜í•œ ê²½ìš° 180Â°ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.</p>
                </div>

                <div class="form-group">
                    <label for="speedSlider">Transfer Speed</label>
                    <div style="display: flex; gap: 12px; align-items: center; margin-top: 8px;">
                        <span style="font-size: 0.85rem; opacity: 0.7;">ğŸŒ Safe</span>
                        <input type="range" id="speedSlider" min="1" max="10" value="5" style="flex: 1;" oninput="updateSpeedDisplay(this.value)">
                        <span style="font-size: 0.85rem; opacity: 0.7;">ğŸš€ Fast</span>
                        <span id="speedValue" style="min-width: 60px; font-size: 0.9rem; font-weight: bold; color: var(--primary-color);">Normal</span>
                    </div>
                    <p class="hint">ì „ì†¡ ì†ë„ë¥¼ ì¡°ì ˆí•˜ì„¸ìš”. ëŠë¦° ì†ë„ëŠ” ì•ˆì •ì ì´ì§€ë§Œ ì˜¤ë˜ ê±¸ë¦¬ê³ , ë¹ ë¥¸ ì†ë„ëŠ” ì¼ë¶€ ê¸°ê¸°ì—ì„œ ì‹¤íŒ¨í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>
                </div>

                <div style="margin-top: 24px;">
                    <h3 style="margin-bottom: 16px; font-size: 1.1rem; color: var(--text-color);">ğŸ“¤ Upload</h3>
                    <button id="uploadBtn" class="btn-success" onclick="uploadToDevice()" disabled>ğŸ“¤ Upload to ESL</button>
                    <div id="uploadProgress" style="display:none; margin-top:16px;">
                        <div style="background:rgba(0,0,0,0.1); border-radius:12px; height:8px; overflow:hidden;">
                            <div id="progressBar" style="background:var(--success-color); height:100%; width:0%; transition:width 0.3s ease; border-radius:12px;"></div>
                        </div>
                        <p id="progressText" style="margin-top:8px; font-size:0.9rem; text-align:center; color: var(--text-secondary);">ì¤€ë¹„ ì¤‘...</p>
                    </div>
                </div>

                <div style="margin-top: 24px;">
                    <h3 style="margin-bottom: 16px; font-size: 1.1rem; color: var(--text-color);">ğŸ¨ Canvas Actions</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <button onclick="undoCanvas()" id="undoBtn" disabled class="btn-secondary">â†¶ Undo</button>
                        <button onclick="redoCanvas()" id="redoBtn" disabled class="btn-secondary">â†· Redo</button>
                    </div>
                    <button onclick="addDemoLayout()" class="btn-secondary">âœ¨ Sample Layout</button>
                    <button onclick="downloadCanvas()" class="btn-secondary">ğŸ’¾ Download PNG</button>
                </div>

                <div style="margin-top: 24px; padding-top: 24px; border-top: 1px solid var(--border-color);">
                    <button onclick="clearCanvas()" style="background: var(--error-color); box-shadow: 0 4px 16px rgba(255, 59, 48, 0.2);">ğŸ—‘ï¸ Clear Canvas</button>
                    <button id="disconnectBtn" onclick="disconnectDevice()" style="display:none; background: var(--text-secondary); margin-top: 8px;">ğŸ”Œ Disconnect Device</button>
                </div>
            </div>

            <div class="card canvas-card">
                <h2>ğŸ¨ Drawing Canvas</h2>
                <p class="hint">ë„¤ì´í‹°ë¸Œ Canvas í¬ê¸°: 296 Ã— 128 px (2.9" ESL í•´ìƒë„ ê³ ì •)</p>

                <div id="uploadArea" class="upload-area" onclick="document.getElementById('fileInput').click()"
                     ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event)">
                    <strong>ğŸ“ ì´ë¯¸ì§€ ë¶ˆëŸ¬ì˜¤ê¸°</strong>
                    <p>í´ë¦­í•˜ì—¬ ì„ íƒí•˜ê±°ë‚˜, ì´ë¯¸ì§€ë¥¼ ëŒì–´ë‹¤ ë†“ìœ¼ì„¸ìš”.</p>
                    <input type="file" id="fileInput" accept="image/*" onchange="loadImage(event)" style="display:none;">
                </div>

                <div class="toolbar">
                    <input type="color" id="colorPicker" class="color-picker" value="#000000" onchange="updateBrushColor(this.value)">

                    <div class="slider-group">
                        <span>Brush Size: <strong id="brushSizeValue">5</strong> px</span>
                        <input type="range" id="brushSize" min="1" max="40" value="5" oninput="updateBrushSize(this.value)">
                    </div>

                    <button id="brushBtn" class="tool-button active" onclick="setTool('brush')">ğŸ–Œï¸ Brush</button>
                    <button id="eraserBtn" class="tool-button" onclick="setTool('eraser')">ğŸ©¹ Eraser</button>
                    <button id="rectBtn" class="tool-button" onclick="addShape('rect')">â¬œ Rectangle</button>
                    <button id="circleBtn" class="tool-button" onclick="addShape('circle')">â­• Circle</button>
                    <button id="lineBtn" class="tool-button" onclick="addShape('line')">ğŸ“ Line</button>
                    <button id="textBtn" class="tool-button" onclick="setTool('text')">ğŸ“ Text</button>
                </div>

                <div class="text-controls" id="textControls">
                    <div style="display: flex; gap: 8px; align-items: center; margin-bottom: 8px;">
                        <input type="text" id="textInput" placeholder="í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”" value="NEMR ESL" style="flex: 1;">
                        <button onclick="commitText()" style="width: auto; padding: 8px 16px; margin: 0;">ì¶”ê°€</button>
                    </div>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <label style="margin: 0; font-size: 0.9rem;">í¬ê¸°:</label>
                        <input type="range" id="fontSizeSlider" min="10" max="48" value="20" style="flex: 1;" oninput="updateFontSize(this.value)">
                        <span id="fontSizeValue" style="min-width: 35px; font-size: 0.9rem; font-weight: bold;">20px</span>
                    </div>
                    <input type="hidden" id="fontSize" value="20">
                </div>

                <div class="canvas-wrapper">
                    <canvas id="drawingCanvas" width="296" height="128"></canvas>
                </div>
            </div>
        </div>

        <div class="card log-card">
            <h2>ğŸ“ Activity Log</h2>
            <div id="logArea"></div>
        </div>
    </div>

    <script>
        const ESL_WIDTH = 296;
        const ESL_HEIGHT = 128;

        let canvas = null;
        let ctx = null;
        let currentTool = 'brush';
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let startX = 0;
        let startY = 0;
        let isShapeDrawing = false;
        let tempCanvas = null;
        let tempCtx = null;
        let canvasRect = null;
        let device = null;
        let cmdCharacteristic = null;
        let imgCharacteristic = null;

        // Dynamic timing values (user adjustable)
        let speedLevel = 5; // Default: Normal speed (1=slowest, 10=fastest)

        function getTimingValues() {
            // Calculate timing based on speed level (1-10)
            const baseMainDelay = 80 - (speedLevel * 7);     // 73ms -> 10ms
            const baseCommandDelay = 150 - (speedLevel * 10); // 140ms -> 50ms
            const baseHandshakeDelay = 50 - (speedLevel * 4); // 46ms -> 10ms
            const baseRetryInterval = Math.max(10, 40 - (speedLevel * 3)); // 37 -> 10

            return {
                mainDelay: Math.max(5, baseMainDelay),
                commandDelay: Math.max(20, baseCommandDelay),
                handshakeDelay: Math.max(5, baseHandshakeDelay),
                retryInterval: baseRetryInterval,
                timeoutLimit: 120 + (speedLevel * 10) // More timeout for faster speeds
            };
        }

        let partMsgSize = 244;
        let partDataSize = 240;
        let payload = [];
        let gotAck = false;
        let currentAck = 0;
        let protocolStep = 0;
        let canvasHistory = [];
        let historyIndex = -1;
        let maxHistory = 50;

        document.addEventListener('DOMContentLoaded', () => {
            initCanvas();
            updateSpeedDisplay(5); // Initialize with default speed
            log('âœ… NEMR ESL Studio Ready â€“ Canvas initialised for 296Ã—128');
            log('ğŸ’¡ Start creating your professional ESL design');

            // Add keyboard shortcuts
            document.addEventListener('keydown', handleKeyboard);
        });

        function handleKeyboard(e) {
            // Ctrl+Z for undo
            if (e.ctrlKey && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undoCanvas();
            }
            // Ctrl+Y or Ctrl+Shift+Z for redo
            if (e.ctrlKey && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                e.preventDefault();
                redoCanvas();
            }
            // Enter to add text when text tool is active
            if (e.key === 'Enter' && currentTool === 'text' && e.target.id === 'textInput') {
                e.preventDefault();
                commitText();
            }
        }


        function initCanvas() {
            canvas = document.getElementById('drawingCanvas');
            ctx = canvas.getContext('2d');

            // Cache canvas rect for performance
            canvasRect = canvas.getBoundingClientRect();

            // Update canvas rect on window resize
            window.addEventListener('resize', () => {
                canvasRect = canvas.getBoundingClientRect();
            });

            // Create temporary canvas for shape preview
            tempCanvas = document.createElement('canvas');
            tempCanvas.width = ESL_WIDTH;
            tempCanvas.height = ESL_HEIGHT;
            tempCtx = tempCanvas.getContext('2d');

            // Set canvas properties
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.lineWidth = 5;
            ctx.strokeStyle = '#000000';
            ctx.fillStyle = '#ffffff';

            // Fill background
            ctx.fillRect(0, 0, ESL_WIDTH, ESL_HEIGHT);

            // Add event listeners
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseout', handleMouseUp);

            // Touch events for mobile
            canvas.addEventListener('touchstart', handleTouch);
            canvas.addEventListener('touchmove', handleTouch);
            canvas.addEventListener('touchend', handleMouseUp);

            // Save initial state
            saveCanvasState();
        }

        function getCanvasCoordinates(clientX, clientY) {
            // Always get fresh rect to handle scroll changes
            const rect = canvas.getBoundingClientRect();
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function handleMouseDown(e) {
            const coords = getCanvasCoordinates(e.clientX, e.clientY);
            startX = coords.x;
            startY = coords.y;
            lastX = startX;
            lastY = startY;

            if (currentTool === 'text') {
                addTextAt(startX, startY);
                return;
            }

            if (currentTool === 'rect' || currentTool === 'circle' || currentTool === 'line') {
                isShapeDrawing = true;
                // Save current canvas state for preview
                tempCtx.drawImage(canvas, 0, 0);
                return;
            }

            if (currentTool === 'brush' || currentTool === 'eraser') {
                isDrawing = true;
                ctx.beginPath();
                ctx.moveTo(startX, startY);
            }
        }

        function handleMouseMove(e) {
            const coords = getCanvasCoordinates(e.clientX, e.clientY);
            const currentX = coords.x;
            const currentY = coords.y;

            if (isShapeDrawing && (currentTool === 'rect' || currentTool === 'circle' || currentTool === 'line')) {
                // Clear canvas and redraw original content
                ctx.clearRect(0, 0, ESL_WIDTH, ESL_HEIGHT);
                ctx.drawImage(tempCanvas, 0, 0);

                // Draw preview shape
                const color = document.getElementById('colorPicker').value;
                const lineWidth = parseInt(document.getElementById('brushSize').value, 10);
                ctx.strokeStyle = color;
                ctx.lineWidth = lineWidth;

                if (currentTool === 'rect') {
                    const width = currentX - startX;
                    const height = currentY - startY;
                    ctx.strokeRect(startX, startY, width, height);
                } else if (currentTool === 'circle') {
                    const radius = Math.sqrt(Math.pow(currentX - startX, 2) + Math.pow(currentY - startY, 2));
                    ctx.beginPath();
                    ctx.arc(startX, startY, radius, 0, 2 * Math.PI);
                    ctx.stroke();
                } else if (currentTool === 'line') {
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(currentX, currentY);
                    ctx.stroke();
                }
                return;
            }

            if (isDrawing && (currentTool === 'brush' || currentTool === 'eraser')) {
                ctx.lineTo(currentX, currentY);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(currentX, currentY);
            }

            lastX = currentX;
            lastY = currentY;
        }

        function handleMouseUp() {
            if (isShapeDrawing) {
                isShapeDrawing = false;
                // Shape is already drawn from preview, just save state
                setTimeout(() => saveCanvasState(), 50);
                log(`âœ¨ Added ${currentTool}`);
                return;
            }

            if (isDrawing) {
                isDrawing = false;
                setTimeout(() => saveCanvasState(), 50);
            }
        }

        function handleTouch(e) {
            e.preventDefault();
            const touch = e.touches[0];

            if (e.type === 'touchstart') {
                handleMouseDown({
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
            } else if (e.type === 'touchmove') {
                handleMouseMove({
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
            } else if (e.type === 'touchend') {
                handleMouseUp();
            }
        }

        function setTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-button').forEach(btn => btn.classList.remove('active'));

            switch (tool) {
                case 'brush':
                    document.getElementById('brushBtn').classList.add('active');
                    ctx.strokeStyle = document.getElementById('colorPicker').value;
                    ctx.lineWidth = parseInt(document.getElementById('brushSize').value, 10);
                    ctx.globalCompositeOperation = 'source-over';
                    hideTextControls();
                    log('ğŸ–Œï¸ Brush enabled');
                    break;
                case 'eraser':
                    document.getElementById('eraserBtn').classList.add('active');
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.lineWidth = parseInt(document.getElementById('brushSize').value, 10);
                    hideTextControls();
                    log('ğŸ§½ Eraser enabled');
                    break;
                case 'text':
                    document.getElementById('textBtn').classList.add('active');
                    showTextControls();
                    log('ğŸ“ Click canvas to place text');
                    break;
                case 'rect':
                    document.getElementById('rectBtn').classList.add('active');
                    hideTextControls();
                    log('â¬œ Rectangle tool - drag to draw');
                    break;
                case 'circle':
                    document.getElementById('circleBtn').classList.add('active');
                    hideTextControls();
                    log('â­• Circle tool - drag to draw');
                    break;
                case 'line':
                    document.getElementById('lineBtn').classList.add('active');
                    hideTextControls();
                    log('ğŸ“ Line tool - drag to draw');
                    break;
                default:
                    hideTextControls();
                    break;
            }
        }

        function addShape(type) {
            setTool(type);
            // Now shapes are drawn interactively - no need for fixed shapes
        }

        function showTextControls() {
            document.getElementById('textControls').style.display = 'flex';
        }

        function hideTextControls() {
            document.getElementById('textControls').style.display = 'none';
        }

        function commitText() {
            if (currentTool !== 'text') {
                setTool('text');
            }
            log('â„¹ï¸ í…ìŠ¤íŠ¸ë¥¼ ì¶”ê°€í•˜ë ¤ë©´ ìº”ë²„ìŠ¤ë¥¼ í´ë¦­í•˜ì„¸ìš”');
        }

        function addTextAt(x, y) {
            const value = document.getElementById('textInput').value.trim();
            if (!value) {
                log('âŒ í…ìŠ¤íŠ¸ ë‚´ìš©ì„ ì…ë ¥í•˜ì„¸ìš”');
                return;
            }
            const fontSize = parseInt(document.getElementById('fontSize').value, 10) || 20;
            const color = document.getElementById('colorPicker').value;

            ctx.fillStyle = color;
            ctx.font = `${fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(value, x, y);

            saveCanvasState();
            log(`ğŸ“ í…ìŠ¤íŠ¸ ì¶”ê°€: "${value}" @ (${Math.round(x)}, ${Math.round(y)})`);
        }

        function updateBrushColor(color) {
            if (currentTool === 'brush') {
                ctx.strokeStyle = color;
            }
        }

        function updateBrushSize(size) {
            const px = parseInt(size, 10);
            document.getElementById('brushSizeValue').textContent = px;
            ctx.lineWidth = px;
        }

        function updateFontSize(size) {
            const px = parseInt(size, 10);
            document.getElementById('fontSizeValue').textContent = px + 'px';
            document.getElementById('fontSize').value = px;
        }

        function clearCanvas() {
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, ESL_WIDTH, ESL_HEIGHT);
            saveCanvasState();
            log('ğŸ—‘ï¸ Canvas cleared');
        }

        function saveCanvasState() {
            // Remove future history if we're not at the end
            if (historyIndex < canvasHistory.length - 1) {
                canvasHistory = canvasHistory.slice(0, historyIndex + 1);
            }

            // Add current state (use getImageData for better performance)
            const imageData = ctx.getImageData(0, 0, ESL_WIDTH, ESL_HEIGHT);
            canvasHistory.push(imageData);

            // Limit history size
            if (canvasHistory.length > maxHistory) {
                canvasHistory.shift();
            } else {
                historyIndex++;
            }

            updateUndoRedoButtons();
        }

        function undoCanvas() {
            if (historyIndex > 0) {
                historyIndex--;
                loadCanvasState(canvasHistory[historyIndex]);
                updateUndoRedoButtons();
                log('â†¶ Undo applied');
            }
        }

        function redoCanvas() {
            if (historyIndex < canvasHistory.length - 1) {
                historyIndex++;
                loadCanvasState(canvasHistory[historyIndex]);
                updateUndoRedoButtons();
                log('â†· Redo applied');
            }
        }

        function loadCanvasState(imageData) {
            ctx.putImageData(imageData, 0, 0);
        }

        function updateUndoRedoButtons() {
            document.getElementById('undoBtn').disabled = historyIndex <= 0;
            document.getElementById('redoBtn').disabled = historyIndex >= canvasHistory.length - 1;
        }

        function addDemoLayout() {
            clearCanvas();

            // Draw header text
            ctx.fillStyle = '#000000';
            ctx.font = 'bold 26px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('íšŒì˜ì‹¤ ì•ˆë‚´', ESL_WIDTH / 2, 28);

            // Draw subtitle
            ctx.fillStyle = '#333333';
            ctx.font = '16px Arial';
            ctx.fillText('NEMR ì „ìê°€ê²©í‘œì‹œê¸° (2.9")', ESL_WIDTH / 2, 56);

            // Draw box
            ctx.strokeStyle = '#1976d2';
            ctx.lineWidth = 2;
            ctx.fillStyle = 'rgba(25,118,210,0.05)';
            ctx.fillRect(16, 72, ESL_WIDTH - 32, 40);
            ctx.strokeRect(16, 72, ESL_WIDTH - 32, 40);

            // Draw time
            ctx.fillStyle = '#000000';
            ctx.font = '20px Arial';
            ctx.fillText('14:30 ~ 15:30', ESL_WIDTH / 2, 92);

            saveCanvasState();
            log('âœ¨ Sample layout inserted');
        }

        function downloadCanvas() {
            const dataURL = canvas.toDataURL('image/png');
            const a = document.createElement('a');
            a.href = dataURL;
            a.download = 'nemr-esl-2.9.png';
            a.click();
            log('ğŸ’¾ Canvas downloaded');
        }

        function loadImage(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    const scale = Math.min(
                        ESL_WIDTH / img.width,
                        ESL_HEIGHT / img.height
                    );
                    const scaledWidth = img.width * scale;
                    const scaledHeight = img.height * scale;
                    const x = (ESL_WIDTH - scaledWidth) / 2;
                    const y = (ESL_HEIGHT - scaledHeight) / 2;

                    ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
                    saveCanvasState();
                    log(`ğŸ“· Image loaded: ${file.name}`);
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function handleDragOver(event) {
            event.preventDefault();
            document.getElementById('uploadArea').classList.add('dragover');
        }

        function handleDragLeave(event) {
            event.preventDefault();
            document.getElementById('uploadArea').classList.remove('dragover');
        }

        function handleDrop(event) {
            event.preventDefault();
            document.getElementById('uploadArea').classList.remove('dragover');
            const files = event.dataTransfer.files;
            if (files && files.length > 0 && files[0].type.startsWith('image/')) {
                loadImage({ target: { files } });
            }
        }

        function updateConnectionStatus(connected) {
            const status = document.getElementById('connectionStatus');
            const connectBtn = document.getElementById('connectBtn');
            const disconnectBtn = document.getElementById('disconnectBtn');
            const uploadBtn = document.getElementById('uploadBtn');

            if (connected) {
                status.classList.remove('disconnected');
                status.classList.add('connected');
                status.textContent = `âœ… Connected to ${device.name}`;
                connectBtn.textContent = 'ğŸ”„ Reconnect';
                disconnectBtn.style.display = 'block';
                uploadBtn.disabled = false;
            } else {
                status.classList.add('disconnected');
                status.classList.remove('connected');
                status.textContent = 'âŒ Not connected';
                connectBtn.textContent = 'ğŸ”— Connect to NEMR Device';
                disconnectBtn.style.display = 'none';
                uploadBtn.disabled = true;
            }
        }


        async function connectDevice() {
            try {
                if (device && device.gatt.connected) {
                    log('âœ… Already connected');
                    return;
                }

                if (device) {
                    // Try to reconnect to existing device
                    log('ğŸ”„ Reconnecting to saved device...');
                    try {
                        const server = await device.gatt.connect();
                        log(`ğŸ”— Reconnected to GATT server (${device.name})`);


                        await setupCharacteristics(server);
                        return;
                    } catch (reconnectError) {
                        log('âŒ Reconnection failed, searching for new device...');
                        device = null;
                    }
                }

                log('ğŸ” Searching for NEMR Bluetooth devices...');
                device = await navigator.bluetooth.requestDevice({
                    filters: [{ namePrefix: 'NEMR' }],
                    optionalServices: ['0000fef0-0000-1000-8000-00805f9b34fb']
                });

                const server = await device.gatt.connect();
                log(`ğŸ”— Connected to GATT server (${device.name})`);

                await setupCharacteristics(server);

            } catch (error) {
                log(`âŒ Connection failed: ${error.message}`);
                updateConnectionStatus(false);
            }
        }

        async function setupCharacteristics(server) {
            const service = await server.getPrimaryService('0000fef0-0000-1000-8000-00805f9b34fb');
            cmdCharacteristic = await service.getCharacteristic('0000fef1-0000-1000-8000-00805f9b34fb');
            imgCharacteristic = await service.getCharacteristic('0000fef2-0000-1000-8000-00805f9b34fb');

            await cmdCharacteristic.startNotifications();
            cmdCharacteristic.addEventListener('characteristicvaluechanged', handleCommandResponse);

            // Add disconnect listener (remove old ones first)
            device.removeEventListener('gattserverdisconnected', handleDeviceDisconnected);
            device.addEventListener('gattserverdisconnected', handleDeviceDisconnected);

            updateConnectionStatus(true);
            log('âœ… Ready to upload');
        }

        function disconnectDevice() {
            if (device && device.gatt.connected) {
                device.gatt.disconnect();
            }
            updateConnectionStatus(false);
            log('ğŸ”Œ Disconnected');
        }

        function handleDeviceDisconnected() {
            log('âš ï¸ Device disconnected');
            updateConnectionStatus(false);
            showUploadProgress(false);

            // Don't clear device reference immediately - allow reconnection
            setTimeout(() => {
                if (device && !device.gatt.connected) {
                    log('ğŸ’¡ Ready to reconnect - click Connect button');
                }
            }, 2000);
        }

        function handleCommandResponse(event) {
            const data = new Uint8Array(event.target.value.buffer);
            const op = data[0];

            if (op === 0x01 && data.length >= 3) {
                partMsgSize = data[1] | (data[2] << 8);
                partDataSize = partMsgSize >= 4 ? (partMsgSize - 4) : 240;
                protocolStep = 1;
                log(`ğŸ“‹ Chunk size negotiated â†’ ${partDataSize} bytes`);
            } else if (op === 0x02) {
                protocolStep = 2;
                log('ğŸ“¨ Size command acknowledged');
            } else if (op === 0x05 && data.length >= 2) {
                const status = data[1];
                if (status === 0x08) {
                    protocolStep = 99;
                    log('âœ… Device confirmed image refresh');
                } else if (status === 0x00 && data.length >= 6) {
                    currentAck = data[2] | (data[3] << 8) | (data[4] << 16) | (data[5] << 24);
                    gotAck = true;
                    log(`ğŸ“¨ ACK received for part ${currentAck}`);
                } else {
                    protocolStep = -1;
                    log(`âŒ Device reported error status 0x${status.toString(16)}`);
                }
            } else {
                log(`ğŸ“¨ CMD 0x${op.toString(16).padStart(2, '0')} (${data.length} bytes)`);
            }
        }

        async function sendCommand(bytes) {
            try {
                await cmdCharacteristic.writeValue(new Uint8Array(bytes));
                return true;
            } catch (error) {
                log(`âŒ Command send failed: ${error.message}`);
                return false;
            }
        }

        async function sendImagePart(partIndex) {
            const offset = partIndex * partDataSize;
            if (offset >= payload.length) {
                return true;
            }
            const chunkLength = Math.min(partDataSize, payload.length - offset);
            const packet = new Uint8Array(4 + chunkLength);
            packet[0] = partIndex & 0xff;
            packet[1] = (partIndex >> 8) & 0xff;
            packet[2] = (partIndex >> 16) & 0xff;
            packet[3] = (partIndex >> 24) & 0xff;
            packet.set(payload.slice(offset, offset + chunkLength), 4);
            try {
                log(`ğŸ“¤ Sending packet ${partIndex} (${chunkLength + 4} bytes)`);
                await imgCharacteristic.writeValue(packet);
                return true;
            } catch (error) {
                log(`âŒ Data part send failed: ${error.message}`);
                return false;
            }
        }

        async function uploadToDevice() {
            if (!cmdCharacteristic || !imgCharacteristic) {
                log('âŒ Connect to a device first');
                return;
            }

            try {
                // Get current speed settings
                const timing = getTimingValues();
                log(`ğŸš€ Transfer speed: Level ${speedLevel} (Main: ${timing.mainDelay}ms, Cmd: ${timing.commandDelay}ms)`);

                showUploadProgress(true);
                updateProgress(0, 'ì´ë¯¸ì§€ ì¤€ë¹„ ì¤‘...');

                const imageData = prepareImageData();
                payload = convertToESLBitmap(imageData);
                log(`ğŸ§® Prepared payload (${payload.length} bytes)`);

                updateProgress(10, 'í•¸ë“œì…°ì´í¬ ì‹œì‘...');
                protocolStep = 0;
                gotAck = false;
                currentAck = 0;

                if (!await sendCommand([0x01])) {
                    showUploadProgress(false);
                    return;
                }

                for (let i = 0; i < timing.timeoutLimit; i++) {
                    if (protocolStep >= 1) break;
                    await delay(timing.handshakeDelay);
                }
                if (protocolStep < 1) {
                    log('âŒ Handshake (0x01) timeout');
                    showUploadProgress(false);
                    return;
                }

                updateProgress(20, 'í¬ê¸° ì •ë³´ ì „ì†¡ ì¤‘...');
                const sizeMsg = new Uint8Array(8);
                sizeMsg[0] = 0x02;
                const total = payload.length;
                sizeMsg[1] = total & 0xff;
                sizeMsg[2] = (total >> 8) & 0xff;
                sizeMsg[3] = (total >> 16) & 0xff;
                sizeMsg[4] = (total >> 24) & 0xff;
                if (!await sendCommand(sizeMsg)) {
                    showUploadProgress(false);
                    return;
                }
                await delay(timing.commandDelay);

                if (!await sendCommand([0x03])) {
                    showUploadProgress(false);
                    return;
                }

                const totalParts = Math.ceil(payload.length / partDataSize);
                updateProgress(30, `ë°ì´í„° ì „ì†¡ ì‹œì‘ (${totalParts} íŒ¨í‚·)...`);
                log(`ğŸšš Sending ${totalParts} packetsâ€¦`);

                let currentPart = 0;
                let lastAck = -1;
                let stallCounter = 0;

                // Wait before starting data transfer
                await delay(timing.commandDelay / 2);

                // Send first packet
                if (!await sendImagePart(currentPart)) {
                    showUploadProgress(false);
                    return;
                }

                while (currentPart < totalParts && stallCounter < timing.timeoutLimit) {
                    await delay(timing.mainDelay);

                    if (protocolStep === 99) {
                        updateProgress(100, 'ì—…ë¡œë“œ ì™„ë£Œ!');
                        log('ğŸ‰ Upload complete');
                        setTimeout(() => showUploadProgress(false), 2000);
                        return;
                    }
                    if (protocolStep === -1) {
                        log('âŒ Device aborted transfer');
                        showUploadProgress(false);
                        return;
                    }

                    if (gotAck && currentAck !== lastAck) {
                        lastAck = currentAck;
                        stallCounter = 0;

                        if (currentAck >= totalParts) {
                            log('âœ… All parts acknowledged');
                            break;
                        }

                        // Send the next packet (original working logic)
                        log(`ğŸ”„ ACK ${currentAck} received`);
                        if (currentAck < totalParts) {
                            currentPart = currentAck;
                            log(`ğŸ“‹ Updated currentPart to ${currentPart}`);
                            if (!await sendImagePart(currentPart)) {
                                showUploadProgress(false);
                                return;
                            }
                        }

                        // Update progress bar
                        const progressPercent = 30 + (currentAck / totalParts) * 60; // 30-90%
                        updateProgress(progressPercent, `ì „ì†¡ ì¤‘... ${currentAck + 1}/${totalParts}`);

                        if (currentAck % 4 === 0) {
                            log(`ğŸ“Š Progress ${currentAck + 1}/${totalParts}`);
                        }

                        gotAck = false;
                    } else {
                        stallCounter++;
                        if (stallCounter % timing.retryInterval === 0) {
                            log(`â³ Stall count: ${stallCounter}, retrying packet ${currentPart}, last ACK was ${currentAck}`);
                            if (!await sendImagePart(currentPart)) {
                                showUploadProgress(false);
                                return;
                            }
                        }
                    }
                }

                if (stallCounter >= timing.timeoutLimit) {
                    log('âŒ Transfer timed out');
                    showUploadProgress(false);
                    return;
                }

                if (protocolStep === 99) {
                    updateProgress(100, 'ESL ìƒˆë¡œê³ ì¹¨ ì™„ë£Œ!');
                    log('âœ… ESL refresh complete');
                    setTimeout(() => {
                        showUploadProgress(false);
                        // Auto-reconnect after successful transfer
                        setTimeout(() => {
                            if (!device || !device.gatt.connected) {
                                log('ğŸ”„ Auto-reconnecting...');
                                connectDevice();
                            }
                        }, 1000);
                    }, 2000);
                } else {
                    log('âš ï¸ Transfer ended without final confirmation');
                    showUploadProgress(false);
                }
            } catch (error) {
                log(`âŒ Upload failed: ${error.message}`);
                showUploadProgress(false);
            }
        }

        function showUploadProgress(show) {
            document.getElementById('uploadProgress').style.display = show ? 'block' : 'none';
            document.getElementById('uploadBtn').disabled = show;
        }

        function updateProgress(percent, text) {
            document.getElementById('progressBar').style.width = `${percent}%`;
            document.getElementById('progressText').textContent = text;
        }

        function prepareImageData() {
            const rotation = parseInt(document.getElementById('rotationSelect').value, 10);
            if (rotation === 180) {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = ESL_WIDTH;
                tempCanvas.height = ESL_HEIGHT;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.translate(ESL_WIDTH, ESL_HEIGHT);
                tempCtx.rotate(Math.PI);
                tempCtx.drawImage(canvas, 0, 0);
                log('ğŸ”„ Applied 180Â° rotation for upload');
                return tempCtx.getImageData(0, 0, ESL_WIDTH, ESL_HEIGHT);
            }

            return ctx.getImageData(0, 0, ESL_WIDTH, ESL_HEIGHT);
        }

        function convertToESLBitmap(imageData) {
            const { width, height, data } = imageData;
            const bytesPerRow = Math.ceil(width / 8);
            const mirrorX = true;

            const bwBuffer = new Uint8Array(bytesPerRow * height);
            const redBuffer = new Uint8Array(bytesPerRow * height);
            bwBuffer.fill(0xff);
            redBuffer.fill(0xff);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idxRGBA = (y * width + x) * 4;
                    const r = data[idxRGBA];
                    const g = data[idxRGBA + 1];
                    const b = data[idxRGBA + 2];

                    const column = Math.floor(x / 8);
                    const bitMask = 0x80 >> (x % 8);
                    const idx = y * bytesPerRow + column;

                    const isRed = r > 150 && r > g + b && (r + g + b) < 600;
                    if (isRed) {
                        redBuffer[idx] &= ~bitMask;
                        bwBuffer[idx] |= bitMask;
                        continue;
                    }

                    const gray = (0.299 * r + 0.587 * g + 0.114 * b);
                    if (gray > 160) {
                        bwBuffer[idx] |= bitMask; // white
                    } else {
                        bwBuffer[idx] &= ~bitMask; // black
                    }
                }
            }

            const packed = [];
            const bytesPerColumn = Math.ceil(height / 8);

            const packPlane = (buffer, oneIsWhite) => {
                for (let x = 0; x < width; x++) {
                    const sourceX = mirrorX ? (width - 1 - x) : x;
                    for (let byteIndex = 0; byteIndex < bytesPerColumn; byteIndex++) {
                        let outByte = 0;
                        for (let bit = 0; bit < 8; bit++) {
                            const y = byteIndex * 8 + bit;
                            if (y >= height) continue;
                            const baseIndex = y * bytesPerRow + Math.floor(sourceX / 8);
                            const mask = 0x80 >> (sourceX % 8);
                            const bitIsOne = (buffer[baseIndex] & mask) !== 0;
                            const eslBit = oneIsWhite ? (bitIsOne ? 1 : 0) : (bitIsOne ? 0 : 1);
                            if (eslBit) {
                                outByte |= (1 << (7 - bit));
                            }
                        }
                        packed.push(outByte);
                    }
                }
            };

            packPlane(bwBuffer, true);
            packPlane(redBuffer, false);

            return packed;
        }

        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function updateSpeedDisplay(value) {
            speedLevel = parseInt(value);
            const timing = getTimingValues();

            const speedNames = {
                1: 'ğŸŒ Ultra Safe', 2: 'ğŸŒ Very Safe', 3: 'ğŸŒ Safe',
                4: 'âš¡ Stable', 5: 'âš¡ Normal', 6: 'âš¡ Fast',
                7: 'ğŸš€ Very Fast', 8: 'ğŸš€ Turbo', 9: 'ğŸš€ Ultra Fast', 10: 'ğŸš€ Maximum'
            };

            document.getElementById('speedValue').textContent = speedNames[speedLevel];

            // Show timing info in tooltip or log
            log(`âš™ï¸ Speed: ${speedNames[speedLevel]} (Main: ${timing.mainDelay}ms, Cmd: ${timing.commandDelay}ms)`);
        }


        function log(message) {
            const logArea = document.getElementById('logArea');
            const stamp = new Date().toLocaleTimeString();
            logArea.textContent += `[${stamp}] ${message}\n`;
            logArea.scrollTop = logArea.scrollHeight;
        }

        if (!navigator.bluetooth) {
            log('âŒ This browser does not support Web Bluetooth. Use Chrome or Edge.');
            document.getElementById('connectBtn').disabled = true;
        } else {
            log('ğŸ§­ Web Bluetooth available');
        }
    </script>
</body>
</html>
