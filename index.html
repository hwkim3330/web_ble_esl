<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEMR Electronic Shelf Label Uploader</title>
    <style>
        :root {
            --primary-color: #2196F3;
            --secondary-color: #FFC107;
            --success-color: #4CAF50;
            --error-color: #F44336;
            --bg-color: #f5f5f5;
            --card-bg: #ffffff;
            --text-color: #333333;
            --border-color: #dddddd;
        }

        [data-theme="dark"] {
            --bg-color: #121212;
            --card-bg: #1e1e1e;
            --text-color: #ffffff;
            --border-color: #333333;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: all 0.3s ease;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            background: var(--card-bg);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        h1 {
            color: var(--primary-color);
            font-size: 2rem;
        }

        .theme-toggle {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .theme-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(33, 150, 243, 0.3);
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .card {
            background: var(--card-bg);
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            border: 1px solid var(--border-color);
        }

        .card h2 {
            margin-bottom: 20px;
            color: var(--primary-color);
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 10px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
        }

        input, select, button {
            width: 100%;
            padding: 12px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            background: var(--card-bg);
            color: var(--text-color);
            font-size: 16px;
            transition: all 0.3s ease;
        }

        input:focus, select:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.1);
        }

        button {
            background: var(--primary-color);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
            margin-bottom: 10px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(33, 150, 243, 0.3);
        }

        button:disabled {
            background: #cccccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-success {
            background: var(--success-color);
        }

        .btn-success:hover {
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.3);
        }

        .canvas-container {
            text-align: center;
            margin: 20px 0;
        }

        canvas {
            border: 2px solid var(--border-color);
            border-radius: 8px;
            max-width: 100%;
            background: white;
        }

        .drawing-canvas {
            border: 2px dashed var(--secondary-color);
            cursor: crosshair;
        }

        .preview-canvas {
            border: 2px solid var(--primary-color);
        }

        .connection-status {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 600;
            text-align: center;
        }

        .connected {
            background: rgba(76, 175, 80, 0.1);
            color: var(--success-color);
            border: 2px solid var(--success-color);
        }

        .disconnected {
            background: rgba(244, 67, 54, 0.1);
            color: var(--error-color);
            border: 2px solid var(--error-color);
        }

        .device-filter {
            background: rgba(255, 193, 7, 0.1);
            border: 2px solid var(--secondary-color);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .drawing-tools {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }

        .color-picker {
            width: 50px !important;
            height: 50px;
            padding: 0;
            border-radius: 50%;
        }

        .brush-size {
            width: 80px !important;
        }

        .tool-active {
            background: var(--success-color) !important;
            color: white !important;
        }

        .upload-area {
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 20px;
        }

        .upload-area:hover {
            border-color: var(--primary-color);
            background: rgba(33, 150, 243, 0.05);
        }

        .upload-area.dragover {
            border-color: var(--primary-color);
            background: rgba(33, 150, 243, 0.1);
        }

        #textControls {
            margin-top: 15px;
            display: flex;
            gap: 10px;
        }

        .rotation-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .rotate-btn {
            width: auto !important;
            padding: 8px 16px;
            background: var(--secondary-color);
            color: #333;
            flex: 1;
            min-width: 80px;
        }

        .rotate-btn:hover {
            box-shadow: 0 4px 12px rgba(255, 193, 7, 0.3);
        }

        .log-area {
            background: #1e1e1e;
            color: #00ff00;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            height: 200px;
            overflow-y: auto;
            margin-top: 20px;
        }

        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr 1fr;
            }
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }

            .header {
                flex-direction: column;
                gap: 20px;
                text-align: center;
            }

            h1 {
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üè∑Ô∏è NEMR Electronic Shelf Label Uploader</h1>
            <button class="theme-toggle" onclick="toggleTheme()">üåô Dark Mode</button>
        </div>

        <div class="device-filter">
            <h3>üîç NEMR Device Filter</h3>
            <p>Only NEMR-labeled Bluetooth devices will be shown in device selection</p>
        </div>

        <div class="main-content">
            <!-- Device Connection -->
            <div class="card">
                <h2>üì± Device Connection</h2>

                <div id="connectionStatus" class="connection-status disconnected">
                    ‚ùå Not Connected - Click Connect to start
                </div>

                <button id="connectBtn" onclick="connectDevice()">üîó Connect to NEMR Device</button>
                <button id="disconnectBtn" onclick="disconnectDevice()" style="display:none;">üîå Disconnect</button>

                <div class="form-group">
                    <label>üìè Display Size:</label>
                    <select id="displaySize" onchange="updateCanvasSize()">
                        <option value="296x128">296x128 (2.9")</option>
                        <option value="200x200">200x200 (1.54")</option>
                        <option value="250x122">250x122 (2.13")</option>
                        <option value="400x300">400x300 (4.2")</option>
                    </select>
                </div>
            </div>

            <!-- Drawing Area -->
            <div class="card">
                <h2>üé® Drawing & Tools</h2>

                <div class="upload-area" onclick="document.getElementById('fileInput').click()"
                     ondrop="handleDrop(event)" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)">
                    <p>üìÅ Click to upload image or drag & drop here</p>
                    <input type="file" id="fileInput" accept="image/*" onchange="loadImage(event)" style="display:none;">
                </div>

                <div class="drawing-tools">
                    <input type="color" id="colorPicker" value="#000000" class="color-picker">
                    <input type="range" id="brushSize" min="1" max="20" value="3" class="brush-size">
                    <button onclick="setTool('brush')" id="brushBtn">üñåÔ∏è Brush</button>
                    <button onclick="setTool('eraser')" id="eraserBtn">üóëÔ∏è Eraser</button>
                </div>

                <div class="drawing-tools">
                    <button onclick="setTool('line')" id="lineBtn">üìè Line</button>
                    <button onclick="setTool('rectangle')" id="rectBtn">‚¨ú Rectangle</button>
                    <button onclick="setTool('circle')" id="circleBtn">‚≠ï Circle</button>
                    <button onclick="setTool('text')" id="textBtn">üìù Text</button>
                </div>

                <div class="drawing-tools">
                    <button onclick="clearDrawingCanvas()">üóëÔ∏è Clear Drawing</button>
                    <button onclick="toggleDrawing()" id="drawToggle">‚úèÔ∏è Draw Mode</button>
                    <button onclick="copyToPreview()">üìã Copy to Preview</button>
                </div>

                <div class="form-group" id="textControls" style="display:none;">
                    <input type="text" id="textInput" placeholder="Enter text..." style="width:70%;">
                    <input type="number" id="fontSize" value="16" min="8" max="72" style="width:25%;" placeholder="Size">
                </div>

                <h3>üñåÔ∏è Drawing Area</h3>
                <div class="canvas-container">
                    <canvas id="drawingCanvas" class="drawing-canvas" width="296" height="128"></canvas>
                </div>
            </div>

            <!-- Preview & Upload -->
            <div class="card">
                <h2>üñºÔ∏è Preview & Upload</h2>

                <div class="canvas-container">
                    <canvas id="canvas" class="preview-canvas" width="296" height="128"></canvas>
                </div>

                <div class="rotation-controls">
                    <button class="rotate-btn" onclick="rotatePreview(-90)">‚Ü∂ 90¬∞</button>
                    <button class="rotate-btn" onclick="rotatePreview(90)">‚Ü∑ 90¬∞</button>
                    <button class="rotate-btn" onclick="rotatePreview(180)">‚Üª 180¬∞</button>
                    <button onclick="clearPreviewCanvas()">üóëÔ∏è Clear Preview</button>
                </div>

                <button id="uploadBtn" onclick="uploadToDevice()" disabled class="btn-success">
                    üì§ Upload to ESL Device
                </button>
            </div>
        </div>

        <div class="log-area" id="logArea"></div>
    </div>

    <script>
        // Global variables
        let device = null;
        let cmdCharacteristic = null;
        let imgCharacteristic = null;
        let canvas = null; // Preview canvas
        let ctx = null;    // Preview context
        let drawingCanvas = null; // Drawing canvas
        let drawingCtx = null;    // Drawing context
        let isDrawing = false;
        let drawingMode = false;
        let currentTool = 'brush';
        let currentRotation = 90; // Default rotation
        let startX = 0, startY = 0;

        // ESL Protocol variables
        let partMsgSize = 244;
        let partDataSize = 240;
        let payload = [];
        let gotAck = false;
        let currentAck = 0;
        let protocolStep = 0;

        // Theme toggle
        function toggleTheme() {
            const body = document.body;
            const currentTheme = body.dataset.theme;
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            body.dataset.theme = newTheme;

            const btn = document.querySelector('.theme-toggle');
            btn.textContent = newTheme === 'dark' ? '‚òÄÔ∏è Light Mode' : 'üåô Dark Mode';

            localStorage.setItem('theme', newTheme);
        }

        // Load saved theme
        document.addEventListener('DOMContentLoaded', function() {
            const savedTheme = localStorage.getItem('theme') || 'light';
            document.body.dataset.theme = savedTheme;

            const btn = document.querySelector('.theme-toggle');
            btn.textContent = savedTheme === 'dark' ? '‚òÄÔ∏è Light Mode' : 'üåô Dark Mode';

            initializeCanvas();
        });

        // Initialize canvases
        function initializeCanvas() {
            // Preview canvas
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');

            // Drawing canvas
            drawingCanvas = document.getElementById('drawingCanvas');
            drawingCtx = drawingCanvas.getContext('2d');

            // Set default canvas backgrounds to white
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawingCtx.fillStyle = 'white';
            drawingCtx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);

            // Apply default rotation to preview
            rotatePreview(currentRotation);

            setupCanvasEvents();
            setTool('brush'); // Set default tool
        }

        // Setup canvas drawing events
        function setupCanvasEvents() {
            // Only drawing canvas should be interactive for drawing
            drawingCanvas.addEventListener('mousedown', startDrawing);
            drawingCanvas.addEventListener('mousemove', draw);
            drawingCanvas.addEventListener('mouseup', stopDrawing);
            drawingCanvas.addEventListener('mouseout', stopDrawing);

            // Touch events for mobile
            drawingCanvas.addEventListener('touchstart', startDrawing);
            drawingCanvas.addEventListener('touchmove', draw);
            drawingCanvas.addEventListener('touchend', stopDrawing);
        }

        // Update canvas size
        function updateCanvasSize() {
            const size = document.getElementById('displaySize').value;
            const [width, height] = size.split('x').map(Number);

            // Update both canvases
            canvas.width = width;
            canvas.height = height;
            drawingCanvas.width = width;
            drawingCanvas.height = height;

            // Clear both canvases
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            drawingCtx.fillStyle = 'white';
            drawingCtx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);

            log(`üìè Canvas size updated to ${width}x${height}`);
        }

        // Drawing functions
        function toggleDrawing() {
            drawingMode = !drawingMode;
            const btn = document.getElementById('drawToggle');
            btn.textContent = drawingMode ? 'üñºÔ∏è View Mode' : '‚úèÔ∏è Draw Mode';

            if (drawingMode) {
                setTool('brush'); // Default to brush when entering draw mode
            } else {
                drawingCanvas.style.cursor = 'default';
                hideTextControls();
            }

            log(`${drawingMode ? '‚úèÔ∏è Drawing mode enabled' : 'üñºÔ∏è View mode enabled'}`);
        }

        function setTool(tool) {
            if (!drawingMode && tool !== 'text') return;

            currentTool = tool;

            // Update button states
            document.querySelectorAll('.drawing-tools button').forEach(btn => {
                btn.classList.remove('tool-active');
            });

            const activeBtn = document.getElementById(tool + 'Btn');
            if (activeBtn) activeBtn.classList.add('tool-active');

            // Update cursor and controls
            switch(tool) {
                case 'brush':
                    drawingCanvas.style.cursor = 'crosshair';
                    hideTextControls();
                    break;
                case 'eraser':
                    drawingCanvas.style.cursor = 'grab';
                    hideTextControls();
                    break;
                case 'line':
                case 'rectangle':
                case 'circle':
                    drawingCanvas.style.cursor = 'crosshair';
                    hideTextControls();
                    break;
                case 'text':
                    drawingCanvas.style.cursor = 'text';
                    showTextControls();
                    break;
            }

            log(`üîß Tool changed to: ${tool}`);
        }

        function showTextControls() {
            document.getElementById('textControls').style.display = 'flex';
        }

        function hideTextControls() {
            document.getElementById('textControls').style.display = 'none';
        }

        // Drawing event handlers
        function startDrawing(event) {
            if (!drawingMode && currentTool !== 'text') return;

            const rect = drawingCanvas.getBoundingClientRect();
            startX = (event.clientX || event.touches[0].clientX) - rect.left;
            startY = (event.clientY || event.touches[0].clientY) - rect.top;

            if (currentTool === 'text') {
                handleTextTool(startX, startY);
                return;
            }

            isDrawing = true;

            if (currentTool === 'brush' || currentTool === 'eraser') {
                draw(event);
            }
        }

        function draw(event) {
            if (!drawingMode) return;

            const rect = drawingCanvas.getBoundingClientRect();
            const currentX = (event.clientX || event.touches[0].clientX) - rect.left;
            const currentY = (event.clientY || event.touches[0].clientY) - rect.top;

            const color = document.getElementById('colorPicker').value;
            const size = parseInt(document.getElementById('brushSize').value);

            if (currentTool === 'brush' && isDrawing) {
                drawingCtx.globalCompositeOperation = 'source-over';
                drawingCtx.fillStyle = color;
                drawingCtx.beginPath();
                drawingCtx.arc(currentX, currentY, size, 0, Math.PI * 2);
                drawingCtx.fill();
            } else if (currentTool === 'eraser' && isDrawing) {
                drawingCtx.globalCompositeOperation = 'destination-out';
                drawingCtx.beginPath();
                drawingCtx.arc(currentX, currentY, size, 0, Math.PI * 2);
                drawingCtx.fill();
                drawingCtx.globalCompositeOperation = 'source-over';
            }
        }

        function stopDrawing(event) {
            if (!isDrawing || !drawingMode) return;
            isDrawing = false;

            const rect = drawingCanvas.getBoundingClientRect();
            const endX = (event.clientX || event.touches[0].clientX) - rect.left;
            const endY = (event.clientY || event.touches[0].clientY) - rect.top;

            const color = document.getElementById('colorPicker').value;
            const size = parseInt(document.getElementById('brushSize').value);

            drawingCtx.strokeStyle = color;
            drawingCtx.lineWidth = size;
            drawingCtx.lineCap = 'round';

            switch(currentTool) {
                case 'line':
                    drawingCtx.beginPath();
                    drawingCtx.moveTo(startX, startY);
                    drawingCtx.lineTo(endX, endY);
                    drawingCtx.stroke();
                    break;

                case 'rectangle':
                    drawingCtx.strokeRect(startX, startY, endX - startX, endY - startY);
                    break;

                case 'circle':
                    const radius = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
                    drawingCtx.beginPath();
                    drawingCtx.arc(startX, startY, radius, 0, Math.PI * 2);
                    drawingCtx.stroke();
                    break;
            }
        }

        function handleTextTool(x, y) {
            const text = document.getElementById('textInput').value;
            const fontSize = parseInt(document.getElementById('fontSize').value);

            if (!text.trim()) {
                log('‚ùå Please enter text first');
                return;
            }

            const color = document.getElementById('colorPicker').value;
            drawingCtx.fillStyle = color;
            drawingCtx.font = `${fontSize}px Arial, sans-serif`;
            drawingCtx.textAlign = 'left';
            drawingCtx.textBaseline = 'top';

            drawingCtx.fillText(text, x, y);
            document.getElementById('textInput').value = '';

            log(`üìù Text added: "${text}" at (${Math.round(x)}, ${Math.round(y)})`);
        }

        // Canvas management
        function clearDrawingCanvas() {
            drawingCtx.fillStyle = 'white';
            drawingCtx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            log('üóëÔ∏è Drawing canvas cleared');
        }

        function clearPreviewCanvas() {
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            log('üóëÔ∏è Preview canvas cleared');
        }

        function copyToPreview() {
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(drawingCanvas, 0, 0);
            log('üìã Drawing copied to preview');
        }

        // Load image from file
        function loadImage(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    // Clear preview canvas
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Calculate scaling to fit canvas
                    const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
                    const x = (canvas.width - img.width * scale) / 2;
                    const y = (canvas.height - img.height * scale) / 2;

                    ctx.drawImage(img, x, y, img.width * scale, img.height * scale);
                    log(`üì∑ Image loaded: ${file.name}`);
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // Handle drag and drop
        function handleDragOver(event) {
            event.preventDefault();
            event.currentTarget.classList.add('dragover');
        }

        function handleDragLeave(event) {
            event.currentTarget.classList.remove('dragover');
        }

        function handleDrop(event) {
            event.preventDefault();
            event.currentTarget.classList.remove('dragover');

            const files = event.dataTransfer.files;
            if (files.length > 0 && files[0].type.startsWith('image/')) {
                const fakeEvent = { target: { files: files } };
                loadImage(fakeEvent);
            }
        }

        // Rotation functions
        function rotatePreview(degrees) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

            // Create temporary canvas for rotation
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');

            if (degrees === 90 || degrees === -90 || degrees === 270) {
                tempCanvas.width = canvas.height;
                tempCanvas.height = canvas.width;
            } else {
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
            }

            // Clear temp canvas
            tempCtx.fillStyle = 'white';
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

            // Apply rotation
            tempCtx.save();
            tempCtx.translate(tempCanvas.width / 2, tempCanvas.height / 2);
            tempCtx.rotate((degrees * Math.PI) / 180);
            tempCtx.drawImage(canvas, -canvas.width / 2, -canvas.height / 2);
            tempCtx.restore();

            // Update main canvas size if needed
            if (degrees === 90 || degrees === -90 || degrees === 270) {
                canvas.width = tempCanvas.width;
                canvas.height = tempCanvas.height;
            }

            // Copy rotated image back
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(tempCanvas, 0, 0);

            log(`üîÑ Preview rotated ${degrees}¬∞`);
        }

        // Connect to NEMR device
        async function connectDevice() {
            try {
                log('üîç Searching for NEMR Bluetooth devices...');

                // Request device with NEMR name filter
                device = await navigator.bluetooth.requestDevice({
                    filters: [{
                        namePrefix: 'NEMR'
                    }],
                    optionalServices: ['0000fef0-0000-1000-8000-00805f9b34fb']
                });

                log(`üì± Found device: ${device.name}`);

                const server = await device.gatt.connect();
                log('üîó Connected to GATT server');

                const service = await server.getPrimaryService('0000fef0-0000-1000-8000-00805f9b34fb');
                cmdCharacteristic = await service.getCharacteristic('0000fef1-0000-1000-8000-00805f9b34fb');
                imgCharacteristic = await service.getCharacteristic('0000fef2-0000-1000-8000-00805f9b34fb');

                // Setup command characteristic notifications
                await cmdCharacteristic.startNotifications();
                cmdCharacteristic.addEventListener('characteristicvaluechanged', handleCommandResponse);

                updateConnectionStatus(true);
                document.getElementById('uploadBtn').disabled = false;

                log('‚úÖ Successfully connected to NEMR device');

            } catch (error) {
                log(`‚ùå Connection failed: ${error.message}`);
                updateConnectionStatus(false);
            }
        }

        // Disconnect device
        function disconnectDevice() {
            if (device && device.gatt.connected) {
                device.gatt.disconnect();
            }
            updateConnectionStatus(false);
            document.getElementById('uploadBtn').disabled = true;
            log('üîå Disconnected from device');
        }

        // Update connection status UI
        function updateConnectionStatus(connected) {
            const status = document.getElementById('connectionStatus');
            const connectBtn = document.getElementById('connectBtn');
            const disconnectBtn = document.getElementById('disconnectBtn');

            if (connected) {
                status.className = 'connection-status connected';
                status.textContent = `‚úÖ Connected to ${device.name}`;
                connectBtn.style.display = 'none';
                disconnectBtn.style.display = 'block';
            } else {
                status.className = 'connection-status disconnected';
                status.textContent = '‚ùå Not Connected - Click Connect to start';
                connectBtn.style.display = 'block';
                disconnectBtn.style.display = 'none';
            }
        }

        // ESL Protocol Implementation
        function handleCommandResponse(event) {
            const data = new Uint8Array(event.target.value.buffer);
            const op = data[0];

            log(`üì® Received command: 0x${op.toString(16).padStart(2, '0')}`);

            switch(op) {
                case 0x01: // Handshake response
                    if (data.length >= 3) {
                        partMsgSize = data[1] | (data[2] << 8);
                        partDataSize = Math.max(partMsgSize - 4, 240);
                        log(`üìã Part size: ${partMsgSize}, Data size: ${partDataSize}`);
                        protocolStep = 1;
                    }
                    break;

                case 0x02: // Ready response
                    protocolStep = 2;
                    log('üîÑ Device ready for data');
                    break;

                case 0x05: // Status/ACK response
                    if (data.length >= 2) {
                        const status = data[1];
                        if (status === 0x08) {
                            log('‚úÖ Upload completed successfully!');
                            protocolStep = 99; // Success
                        } else if (status === 0x00 && data.length >= 6) {
                            currentAck = data[2] | (data[3] << 8) | (data[4] << 16) | (data[5] << 24);
                            gotAck = true;
                            log(`üì® ACK received: part ${currentAck}`);
                        } else {
                            log(`‚ùå Device error: status 0x${status.toString(16)}`);
                            protocolStep = -1; // Error
                        }
                    }
                    break;
            }
        }

        async function sendCommand(data) {
            if (!cmdCharacteristic) return false;
            try {
                await cmdCharacteristic.writeValue(new Uint8Array(data));
                return true;
            } catch (error) {
                log(`‚ùå Command send failed: ${error.message}`);
                return false;
            }
        }

        async function sendImagePart(partIndex) {
            if (!imgCharacteristic) return false;

            const offset = partIndex * partDataSize;
            if (offset >= payload.length) return true;

            const dataSize = Math.min(partDataSize, payload.length - offset);
            const chunk = new Uint8Array(4 + dataSize);

            // Part index (little-endian)
            chunk[0] = partIndex & 0xFF;
            chunk[1] = (partIndex >> 8) & 0xFF;
            chunk[2] = (partIndex >> 16) & 0xFF;
            chunk[3] = (partIndex >> 24) & 0xFF;

            // Data
            chunk.set(payload.slice(offset, offset + dataSize), 4);

            try {
                await imgCharacteristic.writeValue(chunk);
                return true;
            } catch (error) {
                log(`‚ùå Part ${partIndex} send failed: ${error.message}`);
                return false;
            }
        }

        // Upload image to device using proper ESL protocol
        async function uploadToDevice() {
            if (!cmdCharacteristic || !imgCharacteristic) {
                log('‚ùå No device connected');
                return;
            }

            try {
                log('üì§ Starting ESL upload protocol...');

                // Step 1: Convert canvas to ESL bitmap format
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                payload = convertToESLBitmap(imageData);
                log(`üîÑ Prepared ${payload.length} bytes payload`);

                // Reset protocol state
                protocolStep = 0;
                gotAck = false;
                currentAck = 0;

                // Step 2: Send handshake command (0x01)
                log('ü§ù Sending handshake...');
                if (!await sendCommand([0x01])) return;

                // Wait for handshake response
                for (let i = 0; i < 100; i++) {
                    if (protocolStep >= 1) break;
                    await new Promise(resolve => setTimeout(resolve, 30));
                }

                if (protocolStep < 1) {
                    log('‚ùå Handshake failed');
                    return;
                }

                // Step 3: Send data size command (0x02)
                const sizeCmd = new Uint8Array(8);
                sizeCmd[0] = 0x02;
                sizeCmd[1] = payload.length & 0xFF;
                sizeCmd[2] = (payload.length >> 8) & 0xFF;
                sizeCmd[3] = (payload.length >> 16) & 0xFF;
                sizeCmd[4] = (payload.length >> 24) & 0xFF;
                sizeCmd[5] = 0;
                sizeCmd[6] = 0;
                sizeCmd[7] = 0;

                log('üìè Sending data size...');
                if (!await sendCommand(sizeCmd)) return;

                await new Promise(resolve => setTimeout(resolve, 100));

                // Step 4: Send start command (0x03)
                log('üöÄ Sending start command...');
                if (!await sendCommand([0x03])) return;

                // Step 5: Send image data parts
                const totalParts = Math.ceil(payload.length / partDataSize);
                log(`üì° Sending ${totalParts} parts...`);

                let currentPart = 0;
                let lastAckPart = -1;
                let timeoutCount = 0;

                // Send first part
                if (!await sendImagePart(currentPart)) return;

                while (currentPart < totalParts && timeoutCount < 100) {
                    await new Promise(resolve => setTimeout(resolve, 50));

                    if (protocolStep === 99) {
                        // Success!
                        log('‚úÖ Image successfully uploaded to ESL device!');
                        return;
                    }

                    if (protocolStep === -1) {
                        log('‚ùå Device reported error during upload');
                        return;
                    }

                    if (gotAck && currentAck !== lastAckPart) {
                        lastAckPart = currentAck;
                        timeoutCount = 0;

                        if (currentAck >= totalParts) {
                            log('‚úÖ All parts acknowledged!');
                            break;
                        }

                        // Send next part
                        currentPart = currentAck;
                        if (!await sendImagePart(currentPart)) return;

                        if (currentPart % 10 === 0) {
                            log(`üìä Progress: ${currentPart}/${totalParts} parts`);
                        }

                        gotAck = false;
                    } else {
                        timeoutCount++;
                        if (timeoutCount > 30) {
                            // Retry last part
                            log(`üîÑ Retrying part ${currentPart}...`);
                            if (!await sendImagePart(currentPart)) return;
                            timeoutCount = 0;
                        }
                    }
                }

                if (timeoutCount >= 100) {
                    log('‚ùå Upload timeout - device may not be responding');
                } else {
                    log('‚úÖ Upload completed!');
                }

            } catch (error) {
                log(`‚ùå Upload failed: ${error.message}`);
            }
        }

        // Convert image to ESL BWR bitmap format (FIXED VERSION)
        function convertToESLBitmap(imageData) {
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            const bitmap = [];

            const bytesPerRow = Math.ceil(width / 8);
            const mirrorX = true; // Match Arduino MIRROR_X setting

            // Helper function to get bit from buffer
            function getBit(x, y, buffer) {
                const actualX = mirrorX ? (width - 1 - x) : x;
                const idx = y * bytesPerRow + Math.floor(actualX / 8);
                const mask = 0x80 >> (actualX % 8);
                return (buffer[idx] & mask) !== 0;
            }

            // Create BW buffer (BLACK pixels should be 0, WHITE pixels should be 1)
            const bwBuffer = new Uint8Array(bytesPerRow * height);
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;
                    const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    const isWhite = gray > 128;

                    const actualX = mirrorX ? (width - 1 - x) : x;
                    const idx = y * bytesPerRow + Math.floor(actualX / 8);
                    const mask = 0x80 >> (actualX % 8);

                    if (isWhite) {
                        bwBuffer[idx] |= mask;
                    }
                }
            }

            // Create RED buffer - should be mostly empty (WHITE=1) for normal images
            const redBuffer = new Uint8Array(bytesPerRow * height);
            redBuffer.fill(0xFF); // Start with all WHITE (no red pixels)

            // Optionally detect red pixels in the image
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];

                    // Detect red pixels (red dominant and not white/gray)
                    const isRed = r > 150 && r > (g + b) * 1.5 && (r + g + b) < 600;

                    if (isRed) {
                        const actualX = mirrorX ? (width - 1 - x) : x;
                        const idx = y * bytesPerRow + Math.floor(actualX / 8);
                        const mask = 0x80 >> (actualX % 8);
                        redBuffer[idx] &= ~mask; // Clear bit for red pixel (0 = RED, 1 = WHITE)
                    }
                }
            }

            // Pack according to ESL format: for each X column, pack 16 bytes (128 bits) for BW, then 16 bytes for RED
            for (let x = 0; x < width; x++) {
                // Pack BW data for this column
                for (let byteIdx = 0; byteIdx < 16; byteIdx++) {
                    let byte = 0;
                    for (let bit = 0; bit < 8; bit++) {
                        const y = byteIdx * 8 + bit;
                        if (y < height) {
                            if (getBit(x, y, bwBuffer)) {
                                byte |= (1 << (7 - bit));
                            }
                        }
                    }
                    bitmap.push(byte);
                }
            }

            // Pack RED data for each column
            for (let x = 0; x < width; x++) {
                for (let byteIdx = 0; byteIdx < 16; byteIdx++) {
                    let byte = 0;
                    for (let bit = 0; bit < 8; bit++) {
                        const y = byteIdx * 8 + bit;
                        if (y < height) {
                            if (getBit(x, y, redBuffer)) {
                                byte |= (1 << (7 - bit));
                            }
                        }
                    }
                    bitmap.push(byte);
                }
            }

            return bitmap;
        }

        // Logging function
        function log(message) {
            const logArea = document.getElementById('logArea');
            const timestamp = new Date().toLocaleTimeString();
            logArea.innerHTML += `[${timestamp}] ${message}\n`;
            logArea.scrollTop = logArea.scrollHeight;
        }

        // Check for Bluetooth support
        if (!navigator.bluetooth) {
            log('‚ùå Bluetooth API not supported in this browser');
            log('üí° Please use Chrome or Edge for Bluetooth Web API support');
            document.getElementById('connectBtn').disabled = true;
        } else {
            log('‚úÖ Bluetooth Web API supported');
        }
    </script>
</body>
</html>