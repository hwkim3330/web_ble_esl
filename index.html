<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEMR 2.9\" ESL Uploader</title>
    <script src="https://unpkg.com/fabric@5.3.0/dist/fabric.min.js" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/npm/fabric@5.3.0/dist/fabric.min.js'"></script>
    <style>
        :root {
            --primary-color: #1976d2;
            --secondary-color: #ffc107;
            --success-color: #2e7d32;
            --error-color: #d32f2f;
            --bg-color: #f4f6fb;
            --card-bg: #ffffff;
            --text-color: #1f2933;
            --border-color: #d6dee6;
        }

        [data-theme="dark"] {
            --bg-color: #0f172a;
            --card-bg: #111827;
            --text-color: #e2e8f0;
            --border-color: #1f2937;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 24px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            border: 1px solid var(--border-color);
            box-shadow: 0 12px 30px rgba(15, 23, 42, 0.08);
            padding: 24px;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 24px;
            margin-bottom: 24px;
        }

        h1 {
            font-size: 1.9rem;
            color: var(--primary-color);
        }

        .subtitle {
            margin-top: 6px;
            font-size: 0.95rem;
            color: var(--text-color);
            opacity: 0.75;
        }

        .theme-toggle {
            border: none;
            border-radius: 999px;
            padding: 10px 20px;
            background: var(--primary-color);
            color: #fff;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .theme-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 22px rgba(25, 118, 210, 0.35);
        }

        .layout {
            display: grid;
            grid-template-columns: 320px 1fr;
            gap: 24px;
        }

        .form-group {
            margin-top: 18px;
        }

        label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
        }

        select, input[type="number"], input[type="text"] {
            width: 100%;
            padding: 10px 12px;
            border-radius: 10px;
            border: 1px solid var(--border-color);
            background: var(--card-bg);
            color: var(--text-color);
            font-size: 15px;
        }

        button {
            width: 100%;
            padding: 12px;
            border-radius: 12px;
            border: none;
            font-weight: 600;
            cursor: pointer;
            background: var(--primary-color);
            color: #fff;
            margin-top: 12px;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 22px rgba(25, 118, 210, 0.3);
        }

        button:disabled {
            background: #98a2b3;
            cursor: not-allowed;
            box-shadow: none;
        }

        .btn-success {
            background: var(--success-color);
        }

        .status {
            padding: 14px;
            border-radius: 12px;
            font-weight: 600;
            text-align: center;
            border: 1px solid;
        }

        .status.disconnected {
            border-color: rgba(211, 47, 47, 0.4);
            background: rgba(211, 47, 47, 0.08);
            color: var(--error-color);
        }

        .status.connected {
            border-color: rgba(46, 125, 50, 0.4);
            background: rgba(46, 125, 50, 0.1);
            color: var(--success-color);
        }

        .hint {
            margin-top: 6px;
            font-size: 0.85rem;
            color: var(--text-color);
            opacity: 0.7;
        }

        .canvas-card header {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .toolbar {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 16px;
        }

        .color-picker {
            width: 52px;
            height: 52px;
            border-radius: 50%;
            border: none;
            padding: 0;
            cursor: pointer;
        }

        .slider-group {
            background: rgba(25, 118, 210, 0.08);
            border: 1px solid rgba(25, 118, 210, 0.15);
            border-radius: 12px;
            padding: 10px 14px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            font-size: 0.9rem;
        }

        .slider-group input[type="range"] {
            width: 100%;
        }

        .tool-button {
            width: 100%;
            background: rgba(25, 118, 210, 0.08);
            color: var(--text-color);
        }

        .tool-button.active {
            background: var(--primary-color);
            color: #fff;
        }

        .text-controls {
            display: none;
            margin-top: 16px;
            gap: 10px;
        }

        .text-controls input[type="text"] {
            flex: 1;
        }

        .canvas-wrapper {
            margin-top: 18px;
            padding: 18px;
            border-radius: 16px;
            background: rgba(15, 23, 42, 0.04);
            border: 1px dashed var(--border-color);
            display: flex;
            justify-content: center;
        }

        canvas {
            background: #ffffff;
            border-radius: 8px;
            border: 2px solid rgba(15, 23, 42, 0.1);
        }

        .upload-area {
            margin-top: 12px;
            padding: 18px;
            border-radius: 12px;
            border: 2px dashed var(--border-color);
            text-align: center;
            cursor: pointer;
            transition: border-color 0.2s ease, background 0.2s ease;
        }

        .upload-area.dragover {
            border-color: var(--primary-color);
            background: rgba(25, 118, 210, 0.08);
        }

        .log-card {
            margin-top: 24px;
        }

        #logArea {
            margin-top: 12px;
            background: #0b1729;
            color: #7cf29c;
            border-radius: 12px;
            padding: 16px;
            height: 220px;
            overflow-y: auto;
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            font-size: 0.85rem;
            white-space: pre-wrap;
        }

        @media (max-width: 980px) {
            .layout {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="card header">
            <div>
                <h1>üè∑Ô∏è NEMR 2.9" ESL Uploader</h1>
                <p class="subtitle">Fabric.js Í∏∞Î∞ò ÎìúÎ°úÏûâ ¬∑ 296√ó128 Ìï¥ÏÉÅÎèÑ ¬∑ ÏïàÏ†ïÏ†ÅÏù∏ BLE ÌîÑÎ°úÌÜ†ÏΩú</p>
            </div>
            <button class="theme-toggle" onclick="toggleTheme()">üåô Dark Mode</button>
        </div>

        <div class="layout">
            <div class="card control-card">
                <h2>üì° Device & Upload</h2>
                <div id="connectionStatus" class="status disconnected">‚ùå Not connected</div>
                <button id="connectBtn" onclick="connectDevice()">üîó Connect to NEMR Device</button>
                <button id="disconnectBtn" onclick="disconnectDevice()" style="display:none;">üîå Disconnect</button>

                <div class="form-group">
                    <label for="rotationSelect">Orientation</label>
                    <select id="rotationSelect">
                        <option value="0">Landscape (0¬∞)</option>
                        <option value="180">Flip 180¬∞</option>
                    </select>
                    <p class="hint">2.9" Ìå®ÎÑêÏùÄ Í∏∞Î≥∏Ï†ÅÏúºÎ°ú Í∞ÄÎ°úÎ™®ÎìúÏûÖÎãàÎã§. Í±∞Íæ∏Î°ú ÏÑ§ÏπòÌïú Í≤ΩÏö∞ 180¬∞Î•º ÏÇ¨Ïö©ÌïòÏÑ∏Ïöî.</p>
                </div>

                <button id="uploadBtn" class="btn-success" onclick="uploadToDevice()" disabled>üì§ Upload to ESL</button>
                <div id="uploadProgress" style="display:none; margin-top:12px;">
                    <div style="background:#e0e0e0; border-radius:8px; height:8px; overflow:hidden;">
                        <div id="progressBar" style="background:var(--success-color); height:100%; width:0%; transition:width 0.3s ease;"></div>
                    </div>
                    <p id="progressText" style="margin-top:6px; font-size:0.9rem; text-align:center;">Ï§ÄÎπÑ Ï§ë...</p>
                </div>
                <button onclick="downloadCanvas()">üíæ Download PNG</button>
                <button onclick="clearCanvas()">üóëÔ∏è Clear Canvas</button>
                <button onclick="addDemoLayout()">‚ú® Sample Layout</button>
                <button onclick="undoCanvas()" id="undoBtn" disabled>‚Ü∂ Undo</button>
                <button onclick="redoCanvas()" id="redoBtn" disabled>‚Ü∑ Redo</button>
            </div>

            <div class="card canvas-card">
                <h2>üé® Drawing Canvas</h2>
                <p class="hint">Fabric.js Ï∫îÎ≤ÑÏä§ ÌÅ¨Í∏∞: 296 √ó 128 px (2.9" ESL Ìï¥ÏÉÅÎèÑ Í≥†Ï†ï)</p>

                <div id="uploadArea" class="upload-area" onclick="document.getElementById('fileInput').click()"
                     ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event)">
                    <strong>üìÅ Ïù¥ÎØ∏ÏßÄ Î∂àÎü¨Ïò§Í∏∞</strong>
                    <p>ÌÅ¥Î¶≠ÌïòÏó¨ ÏÑ†ÌÉùÌïòÍ±∞ÎÇò, Ïù¥ÎØ∏ÏßÄÎ•º ÎÅåÏñ¥Îã§ ÎÜìÏúºÏÑ∏Ïöî.</p>
                    <input type="file" id="fileInput" accept="image/*" onchange="loadImage(event)" style="display:none;">
                </div>

                <div class="toolbar">
                    <input type="color" id="colorPicker" class="color-picker" value="#000000" onchange="updateBrushColor(this.value)">

                    <div class="slider-group">
                        <span>Brush Size: <strong id="brushSizeValue">5</strong> px</span>
                        <input type="range" id="brushSize" min="1" max="40" value="5" oninput="updateBrushSize(this.value)">
                    </div>

                    <button id="brushBtn" class="tool-button active" onclick="setTool('brush')">üñåÔ∏è Brush</button>
                    <button id="eraserBtn" class="tool-button" onclick="setTool('eraser')">ü©π Eraser</button>
                    <button id="rectBtn" class="tool-button" onclick="addShape('rect')">‚¨ú Rectangle</button>
                    <button id="circleBtn" class="tool-button" onclick="addShape('circle')">‚≠ï Circle</button>
                    <button id="lineBtn" class="tool-button" onclick="addShape('line')">üìè Line</button>
                    <button id="textBtn" class="tool-button" onclick="setTool('text')">üìù Text</button>
                </div>

                <div class="text-controls" id="textControls">
                    <input type="text" id="textInput" placeholder="ÌÖçÏä§Ìä∏Î•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî" value="NEMR ESL">
                    <input type="number" id="fontSize" min="10" max="64" value="20">
                    <button onclick="commitText()">Ï∂îÍ∞Ä</button>
                </div>

                <div class="canvas-wrapper">
                    <canvas id="drawingCanvas" width="296" height="128"></canvas>
                </div>
            </div>
        </div>

        <div class="card log-card">
            <h2>üìù Activity Log</h2>
            <div id="logArea"></div>
        </div>
    </div>

    <script>
        const ESL_WIDTH = 296;
        const ESL_HEIGHT = 128;

        let fabricCanvas = null;
        let currentTool = 'brush';
        let device = null;
        let cmdCharacteristic = null;
        let imgCharacteristic = null;

        let partMsgSize = 244;
        let partDataSize = 240;
        let payload = [];
        let gotAck = false;
        let currentAck = 0;
        let protocolStep = 0;
        let canvasHistory = [];
        let historyIndex = -1;
        let maxHistory = 50;

        document.addEventListener('DOMContentLoaded', () => {
            initTheme();

            // Check if Fabric.js loaded successfully
            if (typeof fabric === 'undefined') {
                log('‚ùå Fabric.js failed to load. Please refresh the page.');
                document.querySelector('.canvas-card').innerHTML = '<h2>‚ö†Ô∏è Loading Error</h2><p>Fabric.js ÎùºÏù¥Î∏åÎü¨Î¶¨Î•º Î°úÎìúÌï† Ïàò ÏóÜÏäµÎãàÎã§. ÌéòÏù¥ÏßÄÎ•º ÏÉàÎ°úÍ≥†Ïπ®Ìï¥Ï£ºÏÑ∏Ïöî.</p>';
                return;
            }

            initCanvas();
            log('‚úÖ Ready ‚Äì Fabric.js canvas initialised for 296√ó128 ESL');
            log('üí° Draw freely, Í∞ÄÏ†∏Ïò® Ïù¥ÎØ∏ÏßÄÎ•º Î∞∞ÏπòÌïòÍ≥† ÏóÖÎ°úÎìúÌïòÏÑ∏Ïöî.');

            // Add keyboard shortcuts
            document.addEventListener('keydown', handleKeyboard);
        });

        function handleKeyboard(e) {
            // Ctrl+Z for undo
            if (e.ctrlKey && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undoCanvas();
            }
            // Ctrl+Y or Ctrl+Shift+Z for redo
            if (e.ctrlKey && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                e.preventDefault();
                redoCanvas();
            }
        }

        function initTheme() {
            const savedTheme = localStorage.getItem('theme') || 'light';
            document.body.dataset.theme = savedTheme;
            const btn = document.querySelector('.theme-toggle');
            btn.textContent = savedTheme === 'dark' ? '‚òÄÔ∏è Light Mode' : 'üåô Dark Mode';
        }

        function toggleTheme() {
            const body = document.body;
            const next = body.dataset.theme === 'dark' ? 'light' : 'dark';
            body.dataset.theme = next;
            localStorage.setItem('theme', next);
            const btn = document.querySelector('.theme-toggle');
            btn.textContent = next === 'dark' ? '‚òÄÔ∏è Light Mode' : 'üåô Dark Mode';
        }

        function initCanvas() {
            fabricCanvas = new fabric.Canvas('drawingCanvas', {
                width: ESL_WIDTH,
                height: ESL_HEIGHT,
                backgroundColor: '#ffffff',
                selection: true,
                preserveObjectStacking: true
            });

            fabricCanvas.freeDrawingBrush = new fabric.PencilBrush(fabricCanvas);
            fabricCanvas.freeDrawingBrush.width = 5;
            fabricCanvas.freeDrawingBrush.color = '#000000';
            fabricCanvas.isDrawingMode = true;

            fabricCanvas.on('mouse:down', (opt) => {
                if (currentTool === 'text') {
                    const pointer = fabricCanvas.getPointer(opt.e);
                    addTextAt(pointer.x, pointer.y);
                }
            });

            // Add canvas history tracking
            fabricCanvas.on('path:created', saveCanvasState);
            fabricCanvas.on('object:added', saveCanvasState);
            fabricCanvas.on('object:removed', saveCanvasState);
            fabricCanvas.on('object:modified', saveCanvasState);

            // Save initial state
            saveCanvasState();
        }

        function setTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-button').forEach(btn => btn.classList.remove('active'));

            switch (tool) {
                case 'brush':
                    document.getElementById('brushBtn').classList.add('active');
                    fabricCanvas.isDrawingMode = true;
                    fabricCanvas.freeDrawingBrush = new fabric.PencilBrush(fabricCanvas);
                    fabricCanvas.freeDrawingBrush.color = document.getElementById('colorPicker').value;
                    fabricCanvas.freeDrawingBrush.width = parseInt(document.getElementById('brushSize').value, 10);
                    hideTextControls();
                    log('üñåÔ∏è Brush enabled');
                    break;
                case 'eraser':
                    document.getElementById('eraserBtn').classList.add('active');
                    fabricCanvas.isDrawingMode = true;
                    fabricCanvas.freeDrawingBrush = new fabric.PencilBrush(fabricCanvas);
                    fabricCanvas.freeDrawingBrush.color = '#ffffff';
                    fabricCanvas.freeDrawingBrush.width = parseInt(document.getElementById('brushSize').value, 10);
                    hideTextControls();
                    log('üßΩ Eraser enabled (draws white)');
                    break;
                case 'text':
                    document.getElementById('textBtn').classList.add('active');
                    fabricCanvas.isDrawingMode = false;
                    showTextControls();
                    log('üìù Click Ï∫îÎ≤ÑÏä§ to place text');
                    break;
                case 'rect':
                case 'circle':
                case 'line':
                    document.getElementById(`${tool}Btn`).classList.add('active');
                    fabricCanvas.isDrawingMode = false;
                    hideTextControls();
                    break;
                default:
                    fabricCanvas.isDrawingMode = false;
                    hideTextControls();
                    break;
            }
        }

        function addShape(type) {
            setTool(type);
            const color = document.getElementById('colorPicker').value;
            const strokeWidth = parseInt(document.getElementById('brushSize').value, 10);
            let obj = null;

            if (type === 'rect') {
                obj = new fabric.Rect({
                    left: 40,
                    top: 30,
                    width: 140,
                    height: 70,
                    fill: 'rgba(0,0,0,0)',
                    stroke: color,
                    strokeWidth,
                    rx: 6,
                    ry: 6
                });
            } else if (type === 'circle') {
                obj = new fabric.Circle({
                    left: 160,
                    top: 40,
                    radius: 32,
                    fill: 'rgba(0,0,0,0)',
                    stroke: color,
                    strokeWidth
                });
            } else if (type === 'line') {
                obj = new fabric.Line([30, 100, 200, 40], {
                    stroke: color,
                    strokeWidth,
                    strokeLineCap: 'round'
                });
            }

            if (obj) {
                fabricCanvas.add(obj);
                fabricCanvas.setActiveObject(obj);
                fabricCanvas.requestRenderAll();
                log(`‚ú® Added ${type}`);
            }
        }

        function showTextControls() {
            document.getElementById('textControls').style.display = 'flex';
        }

        function hideTextControls() {
            document.getElementById('textControls').style.display = 'none';
        }

        function commitText() {
            if (currentTool !== 'text') {
                setTool('text');
            }
            log('‚ÑπÔ∏è ÌÖçÏä§Ìä∏Î•º Ï∂îÍ∞ÄÌïòÎ†§Î©¥ Ï∫îÎ≤ÑÏä§Î•º ÌÅ¥Î¶≠ÌïòÏÑ∏Ïöî');
        }

        function addTextAt(x, y) {
            const value = document.getElementById('textInput').value.trim();
            if (!value) {
                log('‚ùå ÌÖçÏä§Ìä∏ ÎÇ¥Ïö©ÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî');
                return;
            }
            const fontSize = parseInt(document.getElementById('fontSize').value, 10) || 20;
            const color = document.getElementById('colorPicker').value;

            const text = new fabric.Text(value, {
                left: x,
                top: y,
                fontSize,
                originX: 'center',
                originY: 'center',
                fill: color,
                fontFamily: 'Arial'
            });

            fabricCanvas.add(text);
            fabricCanvas.setActiveObject(text);
            fabricCanvas.requestRenderAll();
            log(`üìù ÌÖçÏä§Ìä∏ Ï∂îÍ∞Ä: "${value}" @ (${Math.round(x)}, ${Math.round(y)})`);
        }

        function updateBrushColor(color) {
            if (fabricCanvas.freeDrawingBrush && currentTool === 'brush') {
                fabricCanvas.freeDrawingBrush.color = color;
            }
        }

        function updateBrushSize(size) {
            const px = parseInt(size, 10);
            document.getElementById('brushSizeValue').textContent = px;
            if (fabricCanvas.freeDrawingBrush) {
                fabricCanvas.freeDrawingBrush.width = px;
            }
        }

        function clearCanvas() {
            fabricCanvas.clear();
            fabricCanvas.backgroundColor = '#ffffff';
            fabricCanvas.renderAll();
            saveCanvasState();
            log('üóëÔ∏è Canvas cleared');
        }

        function saveCanvasState() {
            // Remove future history if we're not at the end
            if (historyIndex < canvasHistory.length - 1) {
                canvasHistory = canvasHistory.slice(0, historyIndex + 1);
            }

            // Add current state
            const state = JSON.stringify(fabricCanvas.toJSON());
            canvasHistory.push(state);

            // Limit history size
            if (canvasHistory.length > maxHistory) {
                canvasHistory.shift();
            } else {
                historyIndex++;
            }

            updateUndoRedoButtons();
        }

        function undoCanvas() {
            if (historyIndex > 0) {
                historyIndex--;
                loadCanvasState(canvasHistory[historyIndex]);
                updateUndoRedoButtons();
                log('‚Ü∂ Undo applied');
            }
        }

        function redoCanvas() {
            if (historyIndex < canvasHistory.length - 1) {
                historyIndex++;
                loadCanvasState(canvasHistory[historyIndex]);
                updateUndoRedoButtons();
                log('‚Ü∑ Redo applied');
            }
        }

        function loadCanvasState(state) {
            fabricCanvas.loadFromJSON(state, () => {
                fabricCanvas.renderAll();
            });
        }

        function updateUndoRedoButtons() {
            document.getElementById('undoBtn').disabled = historyIndex <= 0;
            document.getElementById('redoBtn').disabled = historyIndex >= canvasHistory.length - 1;
        }

        function addDemoLayout() {
            clearCanvas();

            const header = new fabric.Text('ÌöåÏùòÏã§ ÏïàÎÇ¥', {
                left: ESL_WIDTH / 2,
                top: 28,
                fontSize: 26,
                fill: '#000000',
                fontWeight: 'bold',
                originX: 'center'
            });

            const subtitle = new fabric.Text('NEMR Ï†ÑÏûêÍ∞ÄÍ≤©ÌëúÏãúÍ∏∞ (2.9")', {
                left: ESL_WIDTH / 2,
                top: 56,
                fontSize: 16,
                fill: '#333333',
                originX: 'center'
            });

            const box = new fabric.Rect({
                left: 16,
                top: 72,
                width: ESL_WIDTH - 32,
                height: 40,
                stroke: '#1976d2',
                strokeWidth: 2,
                fill: 'rgba(25,118,210,0.05)',
                rx: 8,
                ry: 8
            });

            const time = new fabric.Text('14:30 ~ 15:30', {
                left: ESL_WIDTH / 2,
                top: 90,
                fontSize: 20,
                fill: '#000000',
                originX: 'center'
            });

            fabricCanvas.add(box, header, subtitle, time);
            fabricCanvas.requestRenderAll();
            saveCanvasState();
            log('‚ú® Sample layout inserted');
        }

        function downloadCanvas() {
            const dataURL = fabricCanvas.toDataURL({ format: 'png' });
            const a = document.createElement('a');
            a.href = dataURL;
            a.download = 'nemr-esl-2.9.png';
            a.click();
            log('üíæ Canvas downloaded');
        }

        function loadImage(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                fabric.Image.fromURL(e.target.result, (img) => {
                    const scale = Math.min(
                        ESL_WIDTH / img.width,
                        ESL_HEIGHT / img.height
                    );
                    img.set({
                        left: ESL_WIDTH / 2,
                        top: ESL_HEIGHT / 2,
                        originX: 'center',
                        originY: 'center',
                        scaleX: scale,
                        scaleY: scale
                    });
                    fabricCanvas.add(img);
                    fabricCanvas.setActiveObject(img);
                    fabricCanvas.requestRenderAll();
                    log(`üì∑ Image loaded: ${file.name}`);
                }, { crossOrigin: 'anonymous' });
            };
            reader.readAsDataURL(file);
        }

        function handleDragOver(event) {
            event.preventDefault();
            document.getElementById('uploadArea').classList.add('dragover');
        }

        function handleDragLeave(event) {
            event.preventDefault();
            document.getElementById('uploadArea').classList.remove('dragover');
        }

        function handleDrop(event) {
            event.preventDefault();
            document.getElementById('uploadArea').classList.remove('dragover');
            const files = event.dataTransfer.files;
            if (files && files.length > 0 && files[0].type.startsWith('image/')) {
                loadImage({ target: { files } });
            }
        }

        function updateConnectionStatus(connected) {
            const status = document.getElementById('connectionStatus');
            const connectBtn = document.getElementById('connectBtn');
            const disconnectBtn = document.getElementById('disconnectBtn');
            const uploadBtn = document.getElementById('uploadBtn');

            if (connected) {
                status.classList.remove('disconnected');
                status.classList.add('connected');
                status.textContent = `‚úÖ Connected to ${device.name}`;
                connectBtn.style.display = 'none';
                disconnectBtn.style.display = 'block';
                uploadBtn.disabled = false;
            } else {
                status.classList.add('disconnected');
                status.classList.remove('connected');
                status.textContent = '‚ùå Not connected';
                connectBtn.style.display = 'block';
                disconnectBtn.style.display = 'none';
                uploadBtn.disabled = true;
            }
        }

        async function connectDevice() {
            try {
                log('üîç Searching for NEMR Bluetooth devices...');
                device = await navigator.bluetooth.requestDevice({
                    filters: [{ namePrefix: 'NEMR' }],
                    optionalServices: ['0000fef0-0000-1000-8000-00805f9b34fb']
                });

                const server = await device.gatt.connect();
                log(`üîó Connected to GATT server (${device.name})`);

                const service = await server.getPrimaryService('0000fef0-0000-1000-8000-00805f9b34fb');
                cmdCharacteristic = await service.getCharacteristic('0000fef1-0000-1000-8000-00805f9b34fb');
                imgCharacteristic = await service.getCharacteristic('0000fef2-0000-1000-8000-00805f9b34fb');

                await cmdCharacteristic.startNotifications();
                cmdCharacteristic.addEventListener('characteristicvaluechanged', handleCommandResponse);

                // Add disconnect listener
                device.addEventListener('gattserverdisconnected', handleDeviceDisconnected);

                updateConnectionStatus(true);
                log('‚úÖ Ready to upload');
            } catch (error) {
                log(`‚ùå Connection failed: ${error.message}`);
                updateConnectionStatus(false);
            }
        }

        function disconnectDevice() {
            if (device && device.gatt.connected) {
                device.gatt.disconnect();
            }
            updateConnectionStatus(false);
            log('üîå Disconnected');
        }

        function handleDeviceDisconnected() {
            log('‚ö†Ô∏è Device disconnected unexpectedly');
            updateConnectionStatus(false);
            showUploadProgress(false);
            device = null;
            cmdCharacteristic = null;
            imgCharacteristic = null;
        }

        function handleCommandResponse(event) {
            const data = new Uint8Array(event.target.value.buffer);
            const op = data[0];
            log(`üì® CMD 0x${op.toString(16).padStart(2, '0')}`);

            if (op === 0x01 && data.length >= 3) {
                partMsgSize = data[1] | (data[2] << 8);
                partDataSize = partMsgSize >= 4 ? (partMsgSize - 4) : 240;
                protocolStep = 1;
                log(`üìã Chunk size negotiated ‚Üí ${partDataSize} bytes`);
            } else if (op === 0x02) {
                protocolStep = 2;
            } else if (op === 0x05 && data.length >= 2) {
                const status = data[1];
                if (status === 0x08) {
                    protocolStep = 99;
                    log('‚úÖ Device confirmed image refresh');
                } else if (status === 0x00 && data.length >= 6) {
                    currentAck = data[2] | (data[3] << 8) | (data[4] << 16) | (data[5] << 24);
                    gotAck = true;
                } else {
                    protocolStep = -1;
                    log(`‚ùå Device reported error status 0x${status.toString(16)}`);
                }
            }
        }

        async function sendCommand(bytes) {
            try {
                await cmdCharacteristic.writeValue(new Uint8Array(bytes));
                return true;
            } catch (error) {
                log(`‚ùå Command send failed: ${error.message}`);
                return false;
            }
        }

        async function sendImagePart(partIndex) {
            const offset = partIndex * partDataSize;
            if (offset >= payload.length) {
                return true;
            }
            const chunkLength = Math.min(partDataSize, payload.length - offset);
            const packet = new Uint8Array(4 + chunkLength);
            packet[0] = partIndex & 0xff;
            packet[1] = (partIndex >> 8) & 0xff;
            packet[2] = (partIndex >> 16) & 0xff;
            packet[3] = (partIndex >> 24) & 0xff;
            packet.set(payload.slice(offset, offset + chunkLength), 4);
            try {
                await imgCharacteristic.writeValue(packet);
                return true;
            } catch (error) {
                log(`‚ùå Data part send failed: ${error.message}`);
                return false;
            }
        }

        async function uploadToDevice() {
            if (!cmdCharacteristic || !imgCharacteristic) {
                log('‚ùå Connect to a device first');
                return;
            }

            try {
                showUploadProgress(true);
                updateProgress(0, 'Ïù¥ÎØ∏ÏßÄ Ï§ÄÎπÑ Ï§ë...');

                const imageData = prepareImageData();
                payload = convertToESLBitmap(imageData);
                log(`üßÆ Prepared payload (${payload.length} bytes)`);

                updateProgress(10, 'Ìï∏ÎìúÏÖ∞Ïù¥ÌÅ¨ ÏãúÏûë...');
                protocolStep = 0;
                gotAck = false;
                currentAck = 0;

                if (!await sendCommand([0x01])) {
                    showUploadProgress(false);
                    return;
                }

                for (let i = 0; i < 100; i++) {
                    if (protocolStep >= 1) break;
                    await delay(30);
                }
                if (protocolStep < 1) {
                    log('‚ùå Handshake (0x01) timeout');
                    showUploadProgress(false);
                    return;
                }

                updateProgress(20, 'ÌÅ¨Í∏∞ Ï†ïÎ≥¥ Ï†ÑÏÜ° Ï§ë...');
                const sizeMsg = new Uint8Array(8);
                sizeMsg[0] = 0x02;
                const total = payload.length;
                sizeMsg[1] = total & 0xff;
                sizeMsg[2] = (total >> 8) & 0xff;
                sizeMsg[3] = (total >> 16) & 0xff;
                sizeMsg[4] = (total >> 24) & 0xff;
                if (!await sendCommand(sizeMsg)) {
                    showUploadProgress(false);
                    return;
                }
                await delay(100);

                if (!await sendCommand([0x03])) {
                    showUploadProgress(false);
                    return;
                }

                const totalParts = Math.ceil(payload.length / partDataSize);
                updateProgress(30, `Îç∞Ïù¥ÌÑ∞ Ï†ÑÏÜ° ÏãúÏûë (${totalParts} Ìå®ÌÇ∑)...`);
                log(`üöö Sending ${totalParts} packets‚Ä¶`);

                let currentPart = 0;
                let lastAck = -1;
                let stallCounter = 0;

                if (!await sendImagePart(currentPart)) return;

                while (currentPart < totalParts && stallCounter < 120) {
                    await delay(40);

                    if (protocolStep === 99) {
                        updateProgress(100, 'ÏóÖÎ°úÎìú ÏôÑÎ£å!');
                        log('üéâ Upload complete');
                        setTimeout(() => showUploadProgress(false), 2000);
                        return;
                    }
                    if (protocolStep === -1) {
                        log('‚ùå Device aborted transfer');
                        showUploadProgress(false);
                        return;
                    }

                    if (gotAck && currentAck !== lastAck) {
                        lastAck = currentAck;
                        stallCounter = 0;

                        if (currentAck >= totalParts) {
                            log('‚úÖ All parts acknowledged');
                            break;
                        }

                        currentPart = currentAck;
                        if (!await sendImagePart(currentPart)) {
                            showUploadProgress(false);
                            return;
                        }

                        // Update progress bar
                        const progressPercent = 30 + (currentPart / totalParts) * 60; // 30-90%
                        updateProgress(progressPercent, `Ï†ÑÏÜ° Ï§ë... ${currentPart}/${totalParts}`);

                        if (currentPart % 8 === 0) {
                            log(`üìä Progress ${currentPart}/${totalParts}`);
                        }

                        gotAck = false;
                    } else {
                        stallCounter++;
                        if (stallCounter % 30 === 0) {
                            log(`‚è≥ Still waiting for ACK‚Ä¶ retry part ${currentPart}`);
                            if (!await sendImagePart(currentPart)) return;
                        }
                    }
                }

                if (protocolStep === 99) {
                    updateProgress(100, 'ESL ÏÉàÎ°úÍ≥†Ïπ® ÏôÑÎ£å!');
                    log('‚úÖ ESL refresh complete');
                    setTimeout(() => showUploadProgress(false), 2000);
                } else {
                    log('‚ö†Ô∏è Transfer ended without final confirmation');
                    showUploadProgress(false);
                }
            } catch (error) {
                log(`‚ùå Upload failed: ${error.message}`);
                showUploadProgress(false);
            }
        }

        function showUploadProgress(show) {
            document.getElementById('uploadProgress').style.display = show ? 'block' : 'none';
            document.getElementById('uploadBtn').disabled = show;
        }

        function updateProgress(percent, text) {
            document.getElementById('progressBar').style.width = `${percent}%`;
            document.getElementById('progressText').textContent = text;
        }

        function prepareImageData() {
            fabricCanvas.discardActiveObject();
            fabricCanvas.renderAll();

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = ESL_WIDTH;
            tempCanvas.height = ESL_HEIGHT;
            const tempCtx = tempCanvas.getContext('2d');

            tempCtx.fillStyle = '#ffffff';
            tempCtx.fillRect(0, 0, ESL_WIDTH, ESL_HEIGHT);
            tempCtx.drawImage(fabricCanvas.getElement(), 0, 0);

            const rotation = parseInt(document.getElementById('rotationSelect').value, 10);
            if (rotation === 180) {
                const rotatedCanvas = document.createElement('canvas');
                rotatedCanvas.width = ESL_WIDTH;
                rotatedCanvas.height = ESL_HEIGHT;
                const rotatedCtx = rotatedCanvas.getContext('2d');
                rotatedCtx.translate(ESL_WIDTH, ESL_HEIGHT);
                rotatedCtx.rotate(Math.PI);
                rotatedCtx.drawImage(tempCanvas, 0, 0);
                log('üîÑ Applied 180¬∞ rotation for upload');
                return rotatedCtx.getImageData(0, 0, ESL_WIDTH, ESL_HEIGHT);
            }

            return tempCtx.getImageData(0, 0, ESL_WIDTH, ESL_HEIGHT);
        }

        function convertToESLBitmap(imageData) {
            const { width, height, data } = imageData;
            const bytesPerRow = Math.ceil(width / 8);
            const mirrorX = true;

            const bwBuffer = new Uint8Array(bytesPerRow * height);
            const redBuffer = new Uint8Array(bytesPerRow * height);
            bwBuffer.fill(0xff);
            redBuffer.fill(0xff);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idxRGBA = (y * width + x) * 4;
                    const r = data[idxRGBA];
                    const g = data[idxRGBA + 1];
                    const b = data[idxRGBA + 2];

                    const column = Math.floor(x / 8);
                    const bitMask = 0x80 >> (x % 8);
                    const idx = y * bytesPerRow + column;

                    const isRed = r > 150 && r > g + b && (r + g + b) < 600;
                    if (isRed) {
                        redBuffer[idx] &= ~bitMask;
                        bwBuffer[idx] |= bitMask;
                        continue;
                    }

                    const gray = (0.299 * r + 0.587 * g + 0.114 * b);
                    if (gray > 160) {
                        bwBuffer[idx] |= bitMask; // white
                    } else {
                        bwBuffer[idx] &= ~bitMask; // black
                    }
                }
            }

            const packed = [];
            const bytesPerColumn = Math.ceil(height / 8);

            const packPlane = (buffer, oneIsWhite) => {
                for (let x = 0; x < width; x++) {
                    const sourceX = mirrorX ? (width - 1 - x) : x;
                    for (let byteIndex = 0; byteIndex < bytesPerColumn; byteIndex++) {
                        let outByte = 0;
                        for (let bit = 0; bit < 8; bit++) {
                            const y = byteIndex * 8 + bit;
                            if (y >= height) continue;
                            const baseIndex = y * bytesPerRow + Math.floor(sourceX / 8);
                            const mask = 0x80 >> (sourceX % 8);
                            const bitIsOne = (buffer[baseIndex] & mask) !== 0;
                            const eslBit = oneIsWhite ? (bitIsOne ? 1 : 0) : (bitIsOne ? 0 : 1);
                            if (eslBit) {
                                outByte |= (1 << (7 - bit));
                            }
                        }
                        packed.push(outByte);
                    }
                }
            };

            packPlane(bwBuffer, true);
            packPlane(redBuffer, false);

            return packed;
        }

        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function log(message) {
            const logArea = document.getElementById('logArea');
            const stamp = new Date().toLocaleTimeString();
            logArea.textContent += `[${stamp}] ${message}\n`;
            logArea.scrollTop = logArea.scrollHeight;
        }

        if (!navigator.bluetooth) {
            log('‚ùå This browser does not support Web Bluetooth. Use Chrome or Edge.');
            document.getElementById('connectBtn').disabled = true;
        } else {
            log('üß≠ Web Bluetooth available');
        }
    </script>
</body>
</html>
